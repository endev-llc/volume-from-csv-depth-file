<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Depth Data Background Remover</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts: Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #111827; /* bg-gray-900 */
            color: #f3f4f6; /* text-gray-200 */
        }
        #viewer-container {
            width: 100%;
            height: 60vh;
            max-height: 700px;
            background-color: #1f2937; /* bg-gray-800 */
            border-radius: 0.5rem;
            border: 1px solid #374151; /* border-gray-700 */
            cursor: grab;
        }
        #viewer-container:active {
            cursor: grabbing;
        }
        .custom-file-button {
            background-color: #374151; /* bg-gray-700 */
            color: #d1d5db; /* text-gray-300 */
            border: 1px solid #4b5563; /* border-gray-600 */
            padding: 0.5rem 1rem;
            border-radius: 0.375rem;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .custom-file-button:hover {
            background-color: #4b5563; /* bg-gray-600 */
        }
        .process-button {
            background-color: #1d4ed8; /* bg-blue-700 */
            color: white;
            padding: 0.5rem 1.5rem;
            border-radius: 0.375rem;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .process-button:hover {
            background-color: #1e40af; /* bg-blue-800 */
        }
        .process-button:disabled {
            background-color: #374151; /* bg-gray-700 */
            cursor: not-allowed;
            opacity: 0.6;
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen p-4 md:p-8">

    <div class="w-full max-w-4xl mx-auto">
        <header class="text-center mb-8">
            <h1 class="text-3xl md:text-4xl font-bold text-white">Automatic Background Removal for Depth Data</h1>
            <p class="text-gray-400 mt-2">Upload a CSV depth file to isolate the primary object and visualize it in 3D.</p>
        </header>

        <main class="bg-gray-800/50 backdrop-blur-sm p-6 rounded-lg shadow-2xl border border-gray-700">
            <div class="flex flex-col md:flex-row gap-6 mb-6">
                <!-- Controls -->
                <div class="flex-grow">
                    <label for="csvFile" class="block mb-2 text-sm font-medium text-gray-300">1. Upload your Depth CSV File</label>
                    <div class="flex items-center gap-4">
                        <input type="file" id="csvFile" accept=".csv" class="hidden">
                        <label for="csvFile" class="custom-file-button">Choose File</label>
                        <span id="fileName" class="text-gray-400 truncate">No file selected</span>
                    </div>
                </div>
                <div class="flex-shrink-0 self-end">
                     <button id="processBtn" class="process-button w-full md:w-auto" disabled>2. Isolate Object</button>
                </div>
            </div>
            
            <!-- Status and Info -->
            <div id="status" class="text-center text-yellow-400 mb-4 h-6"></div>
            <div id="infoPanel" class="hidden text-center bg-gray-900 p-3 rounded-md mb-4 text-sm">
                <p id="infoText" class="text-gray-300"></p>
            </div>

            <!-- 3D Viewer -->
            <div id="viewer-container"></div>
        </main>

        <footer class="text-center mt-8 text-gray-500 text-sm">
            <p>Powered by Three.js & a custom background removal algorithm.</p>
        </footer>
    </div>

    <!-- Three.js Library -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- DOM Elements ---
        const fileInput = document.getElementById('csvFile');
        const fileNameEl = document.getElementById('fileName');
        const processBtn = document.getElementById('processBtn');
        const viewerContainer = document.getElementById('viewer-container');
        const statusEl = document.getElementById('status');
        const infoPanel = document.getElementById('infoPanel');
        const infoText = document.getElementById('infoText');

        // --- Global State ---
        let scene, camera, renderer, controls;
        let originalPoints = [];
        let currentPointCloud = null;

        // --- Initialization ---
        function init() {
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1f2937); // bg-gray-800

            // Camera setup
            camera = new THREE.PerspectiveCamera(75, viewerContainer.clientWidth / viewerContainer.clientHeight, 0.1, 1000);
            camera.position.set(0, 0, 2); // Position camera to look at the data
            camera.lookAt(0, 0, 0);

            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(viewerContainer.clientWidth, viewerContainer.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            viewerContainer.innerHTML = ''; // Clear any previous content
            viewerContainer.appendChild(renderer.domElement);

            // Controls setup
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.minDistance = 0.1;
            controls.maxDistance = 50;

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(5, 5, 5);
            scene.add(directionalLight);
            
            // Handle window resize
            window.addEventListener('resize', onWindowResize, false);

            // Start animation loop
            animate();
        }

        function onWindowResize() {
            if (!renderer) return;
            camera.aspect = viewerContainer.clientWidth / viewerContainer.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(viewerContainer.clientWidth, viewerContainer.clientHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            if (controls) controls.update();
            if (renderer) renderer.render(scene, camera);
        }
        
        // Initialize the 3D viewer on page load
        init();

        // --- Event Listeners ---
        fileInput.addEventListener('change', handleFileSelect);
        processBtn.addEventListener('click', processData);

        // --- Core Logic ---

        /**
         * Handles the file input change event.
         */
        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) {
                fileNameEl.textContent = 'No file selected';
                processBtn.disabled = true;
                return;
            }
            fileNameEl.textContent = file.name;
            processBtn.disabled = false;
            statusEl.textContent = 'File loaded. Ready to process.';
            infoPanel.classList.add('hidden');
            
            // Clear previous data
            originalPoints = [];
            if (currentPointCloud) {
                scene.remove(currentPointCloud);
                currentPointCloud.geometry.dispose();
                currentPointCloud.material.dispose();
                currentPointCloud = null;
            }

            // Read and parse the file
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    parseCSV(e.target.result);
                    statusEl.textContent = `Parsed ${originalPoints.length} points. Click "Isolate Object".`;
                    visualizePointCloud(originalPoints, "Original Data");
                } catch (error) {
                    statusEl.textContent = `Error parsing CSV: ${error.message}`;
                    console.error(error);
                    processBtn.disabled = true;
                }
            };
            reader.readAsText(file);
        }

        /**
         * Parses the CSV text content into an array of points.
         * Assumes columns are: x, y, depth_meters
         * @param {string} csvText The raw text content of the CSV file.
         */
        function parseCSV(csvText) {
            originalPoints = [];
            const lines = csvText.trim().split('\n');
            const header = lines[0].trim().toLowerCase().split(',').map(h => h.replace(/"/g, ''));
            
            // Find column indices
            const xIndex = header.indexOf('x');
            const yIndex = header.indexOf('y');
            const depthIndex = header.findIndex(h => h.includes('depth'));

            if (xIndex === -1 || yIndex === -1 || depthIndex === -1) {
                throw new Error('CSV must contain "x", "y", and "depth" columns.');
            }

            for (let i = 1; i < lines.length; i++) {
                const values = lines[i].trim().split(',');
                if (values.length >= 3) {
                    const x = parseFloat(values[xIndex]);
                    const y = parseFloat(values[yIndex]);
                    const z = parseFloat(values[depthIndex]); // This is the depth
                    if (!isNaN(x) && !isNaN(y) && !isNaN(z) && z > 0) { // Ensure depth is valid
                        originalPoints.push({ x, y, z });
                    }
                }
            }
        }

        /**
         * Main processing function triggered by the button.
         */
        function processData() {
            if (originalPoints.length === 0) {
                statusEl.textContent = 'No data to process. Please upload a file.';
                return;
            }
            statusEl.textContent = 'Analyzing depth data...';
            
            // Use a timeout to allow the UI to update before the heavy computation
            setTimeout(() => {
                try {
                    // 1. Get all depth values
                    const depths = originalPoints.map(p => p.z);
                    
                    // 2. Automatically find the threshold using Otsu's method
                    const threshold = otsuMethod(depths);
                    
                    // --- FIX START ---
                    // 3. Filter points based on the threshold, creating two groups.
                    //    Instead of assuming the object is always closer, we create both groups
                    //    and then decide which one is the foreground.
                    const groupA_closer = originalPoints.filter(p => p.z <= threshold);
                    const groupB_farther = originalPoints.filter(p => p.z > threshold);
                    
                    // 4. Heuristic: Assume the object is the smaller of the two groups by point count.
                    //    This is often true as the background (like a floor or wall) covers more area.
                    let foregroundPoints;
                    let groupChoice;

                    if (groupA_closer.length < groupB_farther.length) {
                        foregroundPoints = groupA_closer;
                        groupChoice = `closer than ${threshold.toFixed(3)}m`;
                    } else {
                        foregroundPoints = groupB_farther;
                        groupChoice = `farther than ${threshold.toFixed(3)}m`;
                    }
                    // --- FIX END ---

                    statusEl.textContent = 'Background removed. Visualizing isolated object...';
                    infoText.innerHTML = `Found ${foregroundPoints.length} foreground points by selecting the smaller group (${groupChoice}).`;
                    infoPanel.classList.remove('hidden');

                    // 5. Visualize the result
                    visualizePointCloud(foregroundPoints, "Isolated Object");

                } catch (error) {
                    statusEl.textContent = `Error during processing: ${error.message}`;
                    console.error(error);
                }
            }, 50);
        }

        /**
         * Implements Otsu's method to find an optimal threshold for a 1D array of data.
         * This is a classic computer vision algorithm for separating a bimodal histogram.
         * @param {number[]} data - An array of numbers (in our case, depth values).
         * @returns {number} The calculated optimal threshold.
         */
        function otsuMethod(data) {
            if (data.length === 0) {
                return 0; // Or handle as an error
            }

            let min = data[0];
            let max = data[0];
            for (let i = 1; i < data.length; i++) {
                if (data[i] < min) min = data[i];
                if (data[i] > max) max = data[i];
            }

            const numBins = 256;
            const binWidth = (max - min) / numBins;
            
            if (binWidth === 0) return min; // All data points are the same

            const histogram = new Array(numBins).fill(0);
            data.forEach(value => {
                const binIndex = Math.min(numBins - 1, Math.floor((value - min) / binWidth));
                histogram[binIndex]++;
            });

            const total = data.length;
            let sum = 0;
            for (let i = 0; i < numBins; i++) {
                sum += i * histogram[i];
            }

            let sumB = 0;
            let wB = 0; // weight background
            let wF = 0; // weight foreground
            let mB; // mean background
            let mF; // mean foreground
            let maxVariance = 0;
            let bestThreshold = 0;

            for (let t = 0; t < numBins; t++) {
                wB += histogram[t];
                if (wB === 0) continue;

                wF = total - wB;
                if (wF === 0) break;

                sumB += t * histogram[t];
                mB = sumB / wB;
                mF = (sum - sumB) / wF;

                // Calculate between-class variance
                const varianceBetween = wB * wF * (mB - mF) * (mB - mF);

                if (varianceBetween > maxVariance) {
                    maxVariance = varianceBetween;
                    bestThreshold = t;
                }
            }
            
            // Convert the bin index back to the actual data value
            return min + bestThreshold * binWidth;
        }


        /**
         * Creates and displays a 3D point cloud from an array of points.
         * @param {Array<{x: number, y: number, z: number}>} points - The points to visualize.
         */
        function visualizePointCloud(points, name) {
            // Clear existing point cloud from the scene
            if (currentPointCloud) {
                scene.remove(currentPointCloud);
                currentPointCloud.geometry.dispose();
                currentPointCloud.material.dispose();
            }
            
            if (points.length === 0) {
                statusEl.textContent = "No points to display after filtering.";
                return;
            }

            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];

            // Find data bounds to center and scale the cloud
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity, minZ = Infinity, maxZ = -Infinity;
            points.forEach(p => {
                minX = Math.min(minX, p.x); maxX = Math.max(maxX, p.x);
                minY = Math.min(minY, p.y); maxY = Math.max(maxY, p.y);
                minZ = Math.min(minZ, p.z); maxZ = Math.max(maxZ, p.z);
            });
            
            const centerX = (minX + maxX) / 2;
            const centerY = (minY + maxY) / 2;
            const centerZ = (minZ + maxZ) / 2;

            const color = new THREE.Color();
            const hueRange = 0.7; // Use a range of hues (e.g., from red to blue)

            points.forEach(p => {
                // Center the point cloud around the origin (0,0,0) for better camera control.
                // NOTE: The iPhone's (x, y) coordinates might be pixel indices.
                // We scale them down to make the cloud proportional. A scaling factor
                // might need adjustment based on typical CSV resolution.
                const scale = 0.005; 
                positions.push((p.x - centerX) * scale, (p.y - centerY) * scale, p.z);

                // Colorize based on depth (z-value)
                const depthRatio = (p.z - minZ) / (maxZ - minZ || 1);
                color.setHSL(hueRange * (1 - depthRatio), 1.0, 0.5);
                colors.push(color.r, color.g, color.b);
            });

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.computeBoundingSphere();

            const material = new THREE.PointsMaterial({
                size: 0.01,
                vertexColors: true,
                sizeAttenuation: true
            });

            currentPointCloud = new THREE.Points(geometry, material);
            currentPointCloud.name = name;
            scene.add(currentPointCloud);

            // Adjust camera to fit the new point cloud
            const boundingSphere = geometry.boundingSphere;
            const distance = boundingSphere.radius / Math.tan(Math.PI * camera.fov / 360);
            camera.position.set(boundingSphere.center.x, boundingSphere.center.y, boundingSphere.center.z + distance * 1.5);
            camera.lookAt(boundingSphere.center);
            controls.target.copy(boundingSphere.center);
        }

    </script>
</body>
</html>
