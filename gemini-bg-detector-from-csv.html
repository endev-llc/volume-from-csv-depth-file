<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Depth Data Background Segmentation</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* Custom styles for the application */
        body { 
            font-family: 'Inter', sans-serif; 
        }
        /* Simple loader animation */
        .loader {
            border: 6px solid #f3f3f3; /* Light grey */
            border-top: 6px solid #3b82f6; /* Blue */
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1.5s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        /* Style for the canvas to render pixels crisply */
        canvas {
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <div class="container mx-auto p-4 md:p-8 max-w-5xl">
        
        <header class="text-center mb-8">
            <h1 class="text-3xl md:text-4xl font-bold text-gray-900">Depth Image Background Segmentation</h1>
            <p class="text-md text-gray-600 mt-2">Visualize CSV depth data and use the slider to isolate the background.</p>
        </header>

        <main class="bg-white rounded-2xl shadow-xl p-6 md:p-8">
            
            <!-- Controls Section -->
            <div class="controls-section mb-6 p-4 border border-gray-200 rounded-lg bg-gray-50">
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6 items-center">
                    <div>
                        <label for="csvFile" class="block text-sm font-medium text-gray-700 mb-2">Upload your CSV Depth File</label>
                        <input type="file" id="csvFile" accept=".csv" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100 cursor-pointer">
                    </div>
                    <div class="flex items-center justify-center md:justify-start space-x-4">
                         <button id="processButton" class="bg-blue-600 text-white font-bold py-2 px-6 rounded-lg hover:bg-blue-700 transition duration-300 disabled:opacity-50 disabled:cursor-wait">Process Data</button>
                         <div id="loader" class="loader hidden"></div>
                    </div>
                </div>
                 <div class="mt-4">
                    <p class="text-sm text-gray-600">Please select a file to begin. The file must be in CSV format with columns: `x`, `y`, `depth_meters`.</p>
                </div>
            </div>

            <!-- Segmentation Controls & Statistics -->
            <div id="segmentation-controls" class="hidden mb-6 p-4 border border-gray-200 rounded-lg">
                 <h3 class="text-lg font-semibold mb-4 text-gray-800">Segmentation Settings</h3>
                 <div class="grid grid-cols-1 md:grid-cols-2 gap-x-8 gap-y-6">
                    <div>
                        <label for="threshold" class="block text-sm font-medium text-gray-700">Background Depth Threshold</label>
                        <div class="flex items-center space-x-4 mt-2">
                           <input type="range" id="threshold" min="0" max="20" step="0.1" value="10" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                           <span id="threshold-value" class="font-mono text-sm bg-blue-100 text-blue-800 font-semibold py-1 px-3 rounded-md">10.0m</span>
                        </div>
                    </div>
                    <div id="stats" class="text-sm text-gray-600 bg-gray-50 p-3 rounded-lg border">
                        <h4 class="font-semibold text-gray-700 mb-2">Data Statistics</h4>
                        <!-- Stats will be populated by JavaScript -->
                        <p>Loading stats...</p>
                    </div>
                 </div>
            </div>

            <!-- Canvas for Visualization -->
            <div class="canvas-container text-center p-4 bg-gray-200 rounded-lg shadow-inner">
                <p id="canvas-placeholder" class="text-gray-500 py-24">Please upload a CSV file to see the visualization.</p>
                <canvas id="depthCanvas" class="mx-auto bg-gray-200 rounded-lg hidden" style="max-width: 100%;"></canvas>
            </div>
        </main>

        <footer class="text-center mt-8 text-sm text-gray-500">
            <p>Generated by Gemini. This tool runs entirely in your browser.</p>
        </footer>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM Element References ---
            const csvFileInput = document.getElementById('csvFile');
            const processButton = document.getElementById('processButton');
            const loader = document.getElementById('loader');
            const thresholdSlider = document.getElementById('threshold');
            const thresholdValueSpan = document.getElementById('threshold-value');
            const canvas = document.getElementById('depthCanvas');
            const ctx = canvas.getContext('2d');
            const statsDiv = document.getElementById('stats');
            const segmentationControls = document.getElementById('segmentation-controls');
            const canvasPlaceholder = document.getElementById('canvas-placeholder');

            // --- Application State ---
            let depthData = [];
            let imageDimensions = { width: 0, height: 0 };
            let dataStats = { minDepth: Infinity, maxDepth: -Infinity };

            // --- Core Processing Logic ---

            /**
             * Main function to orchestrate the data processing workflow.
             * @param {string} csvText - The raw CSV data as a string.
             */
            const processData = async (csvText) => {
                showLoader(true);
                
                // Use a timeout to allow the UI to update and show the loader
                setTimeout(() => {
                    try {
                        // 1. Parse CSV text into structured data
                        depthData = parseCSV(csvText);
                        if (depthData.length === 0) {
                            alert('The CSV file appears to be empty or in an invalid format.');
                            showLoader(false);
                            return;
                        }

                        // 2. Analyze data to find dimensions and depth range
                        const { dimensions, stats } = analyzeData(depthData);
                        imageDimensions = dimensions;
                        dataStats = stats;

                        // 3. Update UI elements with the new data stats
                        updateUIWithStats();
                        setupCanvas();
                        segmentationControls.classList.remove('hidden');
                        canvas.classList.remove('hidden');
                        canvasPlaceholder.classList.add('hidden');

                        // 4. Perform the initial render of the depth map
                        renderCanvas();
                    } catch (error) {
                        console.error('Error during data processing:', error);
                        alert('An error occurred while processing the file. Please check the console for details.');
                    } finally {
                        showLoader(false);
                    }
                }, 50); // Small delay for UI update
            };

            /**
             * Parses a CSV string into an array of point objects.
             * Assumes format: x,y,depth_meters
             * @param {string} text - The CSV content.
             * @returns {Array<Object>} An array of {x, y, depth} objects.
             */
            const parseCSV = (text) => {
                const points = [];
                const lines = text.trim().split('\n');
                // Start from 1 to skip the header row
                for (let i = 1; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (line) {
                        const parts = line.split(',');
                        if (parts.length === 3) {
                            points.push({
                                x: parseInt(parts[0], 10),
                                y: parseInt(parts[1], 10),
                                depth: parseFloat(parts[2])
                            });
                        }
                    }
                }
                return points;
            };

            /**
             * Analyzes the parsed points to find image dimensions and depth statistics.
             * @param {Array<Object>} points - The array of data points.
             * @returns {Object} An object containing dimensions and stats.
             */
            const analyzeData = (points) => {
                let maxX = 0;
                let maxY = 0;
                let minDepth = Infinity;
                let maxDepth = -Infinity;

                points.forEach(p => {
                    if (p.x > maxX) maxX = p.x;
                    if (p.y > maxY) maxY = p.y;
                    // Ignore 0 depth for stats as it's often an invalid reading
                    if (p.depth > 0) {
                        if (p.depth < minDepth) minDepth = p.depth;
                        if (p.depth > maxDepth) maxDepth = p.depth;
                    }
                });

                return {
                    dimensions: { width: maxX + 1, height: maxY + 1 },
                    stats: { minDepth, maxDepth }
                };
            };

            /**
             * Renders the depth data to the canvas based on the current threshold.
             */
            const renderCanvas = () => {
                if (!depthData.length) return;

                const threshold = parseFloat(thresholdSlider.value);
                const { width, height } = imageDimensions;
                const { minDepth } = dataStats;

                // For performance, we create an ImageData object and manipulate its pixel buffer directly.
                const imageData = ctx.createImageData(width, height);
                const data = imageData.data; // This is a Uint8ClampedArray

                depthData.forEach(p => {
                    // Each pixel is 4 bytes (R, G, B, A)
                    const index = (p.y * width + p.x) * 4;
                    
                    if (p.depth > threshold) {
                        // Background points are colored black
                        data[index] = 0;     // Red
                        data[index + 1] = 0; // Green
                        data[index + 2] = 0; // Blue
                        data[index + 3] = 255; // Alpha
                    } else if (p.depth > 0) {
                        // Foreground points are colored on a grayscale gradient.
                        // Closer points (smaller depth) are brighter (closer to 255).
                        const gray = 255 - ((p.depth - minDepth) / (threshold - minDepth)) * 205;
                        const clampedGray = Math.max(50, Math.min(255, gray));
                        data[index] = clampedGray;
                        data[index + 1] = clampedGray;
                        data[index + 2] = clampedGray;
                        data[index + 3] = 255;
                    }
                    // Pixels with depth 0 or invalid data will remain transparent, showing the canvas background.
                });

                // Draw the manipulated pixel data to the canvas
                ctx.putImageData(imageData, 0, 0);
            };

            // --- UI and Event Handlers ---

            /**
             * Updates the statistics display and slider range.
             */
            const updateUIWithStats = () => {
                statsDiv.innerHTML = `
                    <h4 class="font-semibold text-gray-700 mb-2">Data Statistics</h4>
                    <p>Image Dimensions: <strong class="text-gray-900">${imageDimensions.width} x ${imageDimensions.height}</strong></p>
                    <p>Total Points: <strong class="text-gray-900">${depthData.length.toLocaleString()}</strong></p>
                    <p>Min Depth: <strong class="text-gray-900">${dataStats.minDepth.toFixed(4)}m</strong></p>
                    <p>Max Depth: <strong class="text-gray-900">${dataStats.maxDepth.toFixed(4)}m</strong></p>
                `;
                // Set slider range dynamically based on the data's depth range
                thresholdSlider.min = dataStats.minDepth.toFixed(2);
                thresholdSlider.max = dataStats.maxDepth.toFixed(2);
                // Set a sensible default threshold, e.g., 75% of the way to max depth
                const defaultThreshold = dataStats.minDepth + (dataStats.maxDepth - dataStats.minDepth) * 0.75;
                thresholdSlider.value = defaultThreshold;
                thresholdValueSpan.textContent = `${parseFloat(thresholdSlider.value).toFixed(2)}m`;
            };

            /**
             * Sets the canvas element's width and height attributes.
             */
            const setupCanvas = () => {
                canvas.width = imageDimensions.width;
                canvas.height = imageDimensions.height;
            };

            /**
             * Toggles the visibility of the loading spinner.
             * @param {boolean} isLoading - True to show the loader, false to hide it.
             */
            const showLoader = (isLoading) => {
                if (isLoading) {
                    loader.classList.remove('hidden');
                    processButton.disabled = true;
                } else {
                    loader.classList.add('hidden');
                    processButton.disabled = false;
                }
            };
            
            /**
             * Handles the main "Process" button click event.
             */
            const handleProcessButtonClick = () => {
                const file = csvFileInput.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        processData(e.target.result);
                    };
                    reader.onerror = () => {
                        alert('Error reading the selected file.');
                        showLoader(false);
                    };
                    reader.readAsText(file);
                } else {
                    // If no file is selected, inform the user.
                    alert('Please select a CSV file to begin.');
                }
            };

            // --- Attach Event Listeners ---
            processButton.addEventListener('click', handleProcessButtonClick);
            csvFileInput.addEventListener('change', handleProcessButtonClick); // Also process on new file selection

            thresholdSlider.addEventListener('input', () => {
                thresholdValueSpan.textContent = `${parseFloat(thresholdSlider.value).toFixed(2)}m`;
                // Use requestAnimationFrame to prevent UI lag on rapid slider changes
                requestAnimationFrame(renderCanvas);
            });
            
        });
    </script>

</body>
</html>
