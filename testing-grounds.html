<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Depth Volume Analyzer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            overflow-x: hidden;
        }
        
        .container {
            display: grid;
            grid-template-columns: 380px 1fr;
            height: 100vh;
        }
        
        .sidebar {
            background: rgba(0, 0, 0, 0.3);
            padding: 20px;
            overflow-y: auto;
            backdrop-filter: blur(10px);
        }
        
        .main-view {
            position: relative;
            background: #000;
        }
        
        h1 {
            font-size: 24px;
            margin: 0 0 20px 0;
            background: linear-gradient(45deg, #4facfe, #00f2fe);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .section {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .section h3 {
            margin: 0 0 15px 0;
            font-size: 16px;
            color: #4facfe;
        }
        
        .file-input {
            width: 100%;
            padding: 10px;
            border: 2px dashed #4facfe;
            border-radius: 8px;
            background: rgba(79, 172, 254, 0.1);
            color: white;
            text-align: center;
            cursor: pointer;
            margin-bottom: 10px;
        }
        
        .file-input:hover {
            background: rgba(79, 172, 254, 0.2);
        }
        
        input[type="file"] {
            display: none;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
            color: #ccc;
        }
        
        input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }
        
        .value-display {
            font-family: monospace;
            background: rgba(0, 0, 0, 0.3);
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 12px;
        }
        
        button {
            width: 100%;
            padding: 10px;
            border: none;
            border-radius: 8px;
            background: linear-gradient(45deg, #4facfe, #00f2fe);
            color: black;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s ease;
            margin-bottom: 8px;
        }

        button:hover {
            transform: scale(1.02);
        }

        button.secondary {
            background: rgba(255, 255, 255, 0.2);
            color: white;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 10px;
        }
        
        input[type="checkbox"] {
            width: 16px;
            height: 16px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .stat-item {
            background: rgba(0, 0, 0, 0.3);
            padding: 8px;
            border-radius: 6px;
            text-align: center;
        }
        
        .stat-value {
            font-size: 18px;
            font-weight: bold;
            color: #4facfe;
        }
        
        .stat-label {
            font-size: 11px;
            color: #aaa;
        }
        
        .method-tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
        }
        
        .tab {
            flex: 1;
            padding: 8px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            text-align: center;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
        }
        
        .tab.active {
            background: #4facfe;
            color: black;
        }
        
        .volume-result {
            background: linear-gradient(45deg, #4facfe, #00f2fe);
            color: black;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            font-weight: bold;
            margin-bottom: 15px;
            font-size: 20px;
        }
        
        .voxel-stats {
            background: rgba(79, 172, 254, 0.1);
            border: 1px solid rgba(79, 172, 254, 0.3);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 15px;
            font-size: 12px;
        }
        
        .voxel-stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 8px;
        }
        
        .voxel-stat-item {
            text-align: center;
        }
        
        .voxel-stat-value {
            font-weight: bold;
            color: #4facfe;
            font-size: 14px;
        }
        
        .voxel-stat-label {
            color: #aaa;
            font-size: 10px;
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            z-index: 1000;
        }
        
        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(79, 172, 254, 0.3);
            border-left: 4px solid #4facfe;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .progress-bar {
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            overflow: hidden;
            margin-bottom: 10px;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4facfe, #00f2fe);
            width: 0%;
            transition: width 0.3s ease;
        }
        
        #renderCanvas {
            display: block;
        }

        /* Drawing overlay styles */
        .drawing-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .drawing-overlay.drawing-mode {
            pointer-events: all;
            cursor: crosshair;
        }

        #drawingCanvas {
            width: 100%;
            height: 100%;
            background: transparent;
        }

        .drawing-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 20;
        }

        .draw-btn {
            padding: 8px 12px;
            border: none;
            border-radius: 6px;
            background: rgba(79, 172, 254, 0.9);
            color: black;
            font-weight: bold;
            cursor: pointer;
            font-size: 12px;
            min-width: 80px;
        }

        .draw-btn.active {
            background: #ff4444;
            color: white;
        }

        .draw-btn:hover {
            transform: scale(1.05);
        }

        .mode-indicator {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 14px;
            z-index: 20;
        }

        .drawing-instructions {
            background: rgba(255, 193, 7, 0.9);
            color: black;
            padding: 10px;
            border-radius: 6px;
            font-size: 12px;
            margin-bottom: 10px;
            display: none;
        }

        .drawing-instructions.show {
            display: block;
        }
        
        /* Voxel Legend */
        .voxel-legend {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            padding: 8px;
            margin-top: 10px;
            font-size: 11px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 4px;
        }
        
        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="sidebar">
            <h1>üî¨ 3D Volume Analyzer</h1>
            
            <div class="section">
                <h3>üìÅ Data Input</h3>
                <div class="file-input" onclick="document.getElementById('csvFile').click()">
                    <div>üìä Upload Depth CSV</div>
                    <div style="font-size: 12px; opacity: 0.7;">Click to select file</div>
                </div>
                <input type="file" id="csvFile" accept=".csv" />
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
            </div>
            
            <div class="section" id="statsSection" style="display: none;">
                <h3>üìä Raw Data Statistics</h3>
                <div class="stats-grid" id="statsGrid"></div>
            </div>

            <div class="section" id="segmentationSection" style="display: none;">
                <h3>‚úÇÔ∏è Manual Object Segmentation</h3>
                <div class="drawing-instructions" id="drawingInstructions">
                    üé® <strong>Drawing Mode Active!</strong><br>
                    Circle/outline the object you want to analyze, then click "Apply Segmentation"
                </div>
                <div class="control-group">
                    <button id="enableDrawingBtn">üñäÔ∏è Start Drawing</button>
                    <button id="clearDrawingBtn" class="secondary">üóëÔ∏è Clear Drawing</button>
                    <button id="applySegmentationBtn" class="secondary">‚úÖ Apply Segmentation</button>
                </div>
                <div class="control-group">
                    <label>Points in Selection: <span class="value-display" id="segmentedPointsCount">0</span></label>
                </div>
            </div>

            <div class="section" id="advancedSection" style="display: none;">
                <h3>‚öôÔ∏è Calibration</h3>
                <div class="control-group">
                    <label>Camera FOV (Horiz.): <span class="value-display" id="fovValue">62</span>¬∞</label>
                    <input type="range" id="cameraFov" min="40" max="90" step="1" value="62">
                </div>
            </div>
            
            <div class="section" id="volumeSection" style="display: none;">
                <h3>üìê Volume Calculation</h3>
                <div class="method-tabs">
                    <div class="tab active" data-method="voxel">Voxel</div>
                </div>
                <div class="volume-result" id="volumeResult">
                    Volume: 0 cm¬≥
                </div>
                <div class="control-group" id="voxelControl">
                    <label>Voxel Size: <span class="value-display" id="voxelSizeValue">0.005</span>m</label>
                    <input type="range" id="voxelSize" min="0.001" max="0.05" step="0.001" value="0.005">
                </div>
                
                <!-- Voxel Statistics -->
                <div class="voxel-stats" id="voxelStats" style="display: none;">
                    <div style="font-weight: bold; margin-bottom: 8px;">üìä Voxel Analysis</div>
                    <div class="voxel-stats-grid">
                        <div class="voxel-stat-item">
                            <div class="voxel-stat-value" id="occupiedVoxels">0</div>
                            <div class="voxel-stat-label">Occupied</div>
                        </div>
                        <div class="voxel-stat-item">
                            <div class="voxel-stat-value" id="totalVoxels">0</div>
                            <div class="voxel-stat-label">Total Grid</div>
                        </div>
                        <div class="voxel-stat-item">
                            <div class="voxel-stat-value" id="voxelVolume">0</div>
                            <div class="voxel-stat-label">Per Voxel (cm¬≥)</div>
                        </div>
                        <div class="voxel-stat-item">
                            <div class="voxel-stat-value" id="occupancyRate">0%</div>
                            <div class="voxel-stat-label">Occupancy</div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="section" id="vizSection" style="display: none;">
                <h3>üëÅÔ∏è Visualization</h3>
                <div class="checkbox-group">
                    <input type="checkbox" id="showPointCloud" checked>
                    <label for="showPointCloud">Point Cloud</label>
                </div>
                 <div class="checkbox-group">
                    <input type="checkbox" id="showMesh" checked>
                    <label for="showMesh">Mesh Surface</label>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="showVoxelGrid">
                    <label for="showVoxelGrid">Voxel Grid</label>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="showOccupiedVoxels">
                    <label for="showOccupiedVoxels">Occupied Voxels</label>
                </div>
                <div class="control-group">
                    <label>Point Size: <span class="value-display" id="pointSizeValue">2</span></label>
                    <input type="range" id="pointSize" min="1" max="10" step="1" value="2">
                </div>
                <div class="control-group">
                    <label>Voxel Opacity: <span class="value-display" id="voxelOpacityValue">0.3</span></label>
                    <input type="range" id="voxelOpacity" min="0.1" max="1.0" step="0.1" value="0.3">
                </div>
                
                <!-- Voxel Legend -->
                <div class="voxel-legend">
                    <div style="font-weight: bold; margin-bottom: 6px;">Voxel Legend:</div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #4facfe;"></div>
                        <span>Occupied Voxels</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #333; border-color: #666;"></div>
                        <span>Empty Grid (when visible)</span>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="main-view">
            <canvas id="renderCanvas"></canvas>
            
            <!-- Drawing overlay -->
            <div class="drawing-overlay" id="drawingOverlay">
                <canvas id="drawingCanvas"></canvas>
            </div>

            <!-- Drawing controls -->
            <div class="drawing-controls" id="drawingControls" style="display: none;">
                <button class="draw-btn" id="toggleDrawBtn">üñäÔ∏è Draw</button>
                <button class="draw-btn" id="clearBtn">üóëÔ∏è Clear</button>
                <button class="draw-btn" id="doneBtn">‚úÖ Done</button>
            </div>

            <!-- Mode indicator -->
            <div class="mode-indicator" id="modeIndicator">Navigation Mode</div>
            
            <div class="loading" id="loading" style="display: none;">
                <div class="spinner"></div>
                <div id="loadingText">Processing...</div>
            </div>
        </div>
    </div>

    <script>
        // --- Global State ---
        let scene, camera, renderer, controls;
        let pointCloud, meshSurface;
        let voxelGridLines, occupiedVoxelsGroup;
        
        let rawDepthData = [];
        let segmentedData = [];
        let finalPoints = [];
        let metricPointCloud = [];
        let vizPointCloud = [];
        let voxelData = { occupied: new Set(), bounds: null, voxelSize: 0 };
        
        let stats = {};
        let currentMethod = 'voxel';

        // Drawing state
        let isDrawingMode = false;
        let isDrawing = false;
        let drawingPath = [];
        let drawingContext;
        let drawingCanvas;
        let depthImageCanvas; // For visualizing depth data as 2D image

        // --- Initialization ---
        function initThreeJS() {
            const canvas = document.getElementById('renderCanvas');
            const container = canvas.parentElement;
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0a);
            
            camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.01, 1000);
            camera.position.set(0.5, 0.5, 0.5);
            camera.lookAt(0, 0, 0);
            
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);
            
            setupBasicControls();
            scene.add(new THREE.AxesHelper(0.5));
            animate();
            
            window.addEventListener('resize', onWindowResize);
        }

        function initDrawingCanvas() {
            drawingCanvas = document.getElementById('drawingCanvas');
            drawingContext = drawingCanvas.getContext('2d');
            
            const container = document.querySelector('.main-view');
            drawingCanvas.width = container.clientWidth;
            drawingCanvas.height = container.clientHeight;
            
            setupDrawingEvents();
        }

        // --- Drawing Functionality ---
        function setupDrawingEvents() {
            const overlay = document.getElementById('drawingOverlay');
            
            // Mouse events
            drawingCanvas.addEventListener('mousedown', startDrawing);
            drawingCanvas.addEventListener('mousemove', draw);
            drawingCanvas.addEventListener('mouseup', stopDrawing);
            drawingCanvas.addEventListener('mouseout', stopDrawing);
            
            // Touch events for mobile
            drawingCanvas.addEventListener('touchstart', handleTouch);
            drawingCanvas.addEventListener('touchmove', handleTouch);
            drawingCanvas.addEventListener('touchend', stopDrawing);
        }

        function enableDrawingMode() {
            isDrawingMode = true;
            document.getElementById('drawingOverlay').classList.add('drawing-mode');
            document.getElementById('drawingControls').style.display = 'flex';
            document.getElementById('modeIndicator').textContent = 'Drawing Mode - Click and drag to outline object';
            document.getElementById('drawingInstructions').classList.add('show');
            document.getElementById('enableDrawingBtn').textContent = 'üö´ Exit Drawing';
            
            // Show depth data as 2D visualization for easier drawing
            showDepthVisualization();
        }

        function disableDrawingMode() {
            isDrawingMode = false;
            isDrawing = false;
            document.getElementById('drawingOverlay').classList.remove('drawing-mode');
            document.getElementById('drawingControls').style.display = 'none';
            document.getElementById('modeIndicator').textContent = 'Navigation Mode';
            document.getElementById('drawingInstructions').classList.remove('show');
            document.getElementById('enableDrawingBtn').textContent = 'üñäÔ∏è Start Drawing';
            
            // Hide depth visualization
            hideDepthVisualization();
        }

        function startDrawing(e) {
            if (!isDrawingMode) return;
            isDrawing = true;
            drawingPath = [];
            
            const rect = drawingCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            drawingPath.push({x, y});
            
            drawingContext.beginPath();
            drawingContext.moveTo(x, y);
            drawingContext.strokeStyle = '#ff4444';
            drawingContext.lineWidth = 3;
            drawingContext.lineCap = 'round';
        }

        function draw(e) {
            if (!isDrawing || !isDrawingMode) return;
            
            const rect = drawingCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            drawingPath.push({x, y});
            
            drawingContext.lineTo(x, y);
            drawingContext.stroke();
        }

        function stopDrawing() {
            if (!isDrawing) return;
            isDrawing = false;
            
            // Close the path if we have enough points
            if (drawingPath.length > 2) {
                drawingContext.closePath();
                drawingContext.stroke();
            }
        }

        function handleTouch(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent(e.type === 'touchstart' ? 'mousedown' : 
                                            e.type === 'touchmove' ? 'mousemove' : 'mouseup', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            drawingCanvas.dispatchEvent(mouseEvent);
        }

        function clearDrawing() {
            drawingContext.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
            drawingPath = [];
            document.getElementById('segmentedPointsCount').textContent = '0';
            
            // Show depth visualization again
            if (isDrawingMode) {
                showDepthVisualization();
            }
        }

        // --- Depth Data Visualization ---
        function showDepthVisualization() {
            if (rawDepthData.length === 0) return;
            
            const canvas = drawingCanvas;
            const ctx = drawingContext;
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Create a 2D visualization of the depth data
            const imageWidth = stats.imageWidth;
            const imageHeight = stats.imageHeight;
            
            if (imageWidth === 0 || imageHeight === 0) return;
            
            // Calculate scale to fit the canvas
            const scaleX = canvas.width / imageWidth;
            const scaleY = canvas.height / imageHeight;
            const scale = Math.min(scaleX, scaleY);
            
            const offsetX = (canvas.width - imageWidth * scale) / 2;
            const offsetY = (canvas.height - imageHeight * scale) / 2;
            
            // Draw depth points as colored dots
            ctx.save();
            for (const point of rawDepthData) {
                const x = offsetX + point.x * scale;
                const y = offsetY + point.y * scale;
                
                // Color based on depth (closer = brighter)
                const normalizedDepth = (point.depth - stats.minDepth) / (stats.maxDepth - stats.minDepth);
                const intensity = Math.floor((1 - normalizedDepth) * 255);
                
                ctx.fillStyle = `rgb(${intensity}, ${Math.floor(intensity * 0.8)}, ${Math.floor(intensity * 0.6)})`;
                ctx.fillRect(Math.floor(x), Math.floor(y), Math.ceil(scale), Math.ceil(scale));
            }
            ctx.restore();
            
            // Add instructions overlay
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(10, 10, 300, 50);
            ctx.fillStyle = 'white';
            ctx.font = '14px Arial';
            ctx.fillText('Draw around the object you want to analyze', 20, 30);
            ctx.fillText('Brighter areas = closer to camera', 20, 50);
        }

        function hideDepthVisualization() {
            drawingContext.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
        }

        // --- Point-in-Polygon Algorithm ---
        function pointInPolygon(point, polygon) {
            let inside = false;
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                if (((polygon[i].y > point.y) !== (polygon[j].y > point.y)) &&
                    (point.x < (polygon[j].x - polygon[i].x) * (point.y - polygon[i].y) / (polygon[j].y - polygon[i].y) + polygon[i].x)) {
                    inside = !inside;
                }
            }
            return inside;
        }

        // --- Data Processing Pipeline ---
        async function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            showLoading(true, 'Parsing CSV...');
            updateProgress(0);

            try {
                const text = await file.text();
                updateProgress(20);
                
                await parseCSVData(text);
                updateProgress(40);
                
                showUI();
                
                // Initialize with all data
                segmentedData = [...rawDepthData];
                document.getElementById('segmentedPointsCount').textContent = segmentedData.length.toLocaleString();
                
                await runFullPipeline();

            } catch (error) {
                console.error('Error processing file:', error);
                alert('Error processing file. Check console for details.');
            } finally {
                showLoading(false);
            }
        }

        async function applySegmentation() {
            if (drawingPath.length < 3) {
                alert('Please draw a complete outline around the object first.');
                return;
            }

            showLoading(true, 'Applying segmentation...');
            await new Promise(r => setTimeout(r, 10));

            // Convert drawing coordinates to depth data coordinates
            const canvas = drawingCanvas;
            const imageWidth = stats.imageWidth;
            const imageHeight = stats.imageHeight;
            
            const scaleX = canvas.width / imageWidth;
            const scaleY = canvas.height / imageHeight;
            const scale = Math.min(scaleX, scaleY);
            
            const offsetX = (canvas.width - imageWidth * scale) / 2;
            const offsetY = (canvas.height - imageHeight * scale) / 2;
            
            // Convert drawing path to depth coordinate space
            const depthSpacePath = drawingPath.map(p => ({
                x: (p.x - offsetX) / scale,
                y: (p.y - offsetY) / scale
            }));
            
            // Filter points that are inside the drawn polygon
            segmentedData = rawDepthData.filter(point => {
                return pointInPolygon(point, depthSpacePath);
            });
            
            document.getElementById('segmentedPointsCount').textContent = segmentedData.length.toLocaleString();
            
            if (segmentedData.length === 0) {
                alert('No points found in the selected area. Try drawing a larger selection.');
                showLoading(false);
                return;
            }
            
            await runFullPipeline();
            
            // Exit drawing mode
            disableDrawingMode();
        }
        
        async function runFullPipeline() {
            finalPoints = [...segmentedData];
            await calculateAndVisualize();
        }

        async function calculateAndVisualize() {
            if (finalPoints.length === 0) {
                showLoading(false);
                updateVisualization(); // Clear the screen
                updateVolumeDisplay(0);
                updateVoxelStats(0, 0, 0);
                return;
            }
            
            showLoading(true, 'Creating metric model...');
            await new Promise(r => setTimeout(r, 10));
            createMetricPointCloud();

            showLoading(true, 'Calculating volume...');
            await new Promise(r => setTimeout(r, 10));
            calculateVolume();

            showLoading(true, 'Generating visualization...');
            await new Promise(r => setTimeout(r, 10));
            createVisualizationData();
            updateVisualization();

            showLoading(false);
        }

        async function parseCSVData(text) {
            return new Promise(resolve => {
                const lines = text.trim().split('\n');
                rawDepthData = [];
                let minDepth = Infinity, maxDepth = -Infinity;
                let maxX = -Infinity, maxY = -Infinity;
                
                for (let i = 1; i < lines.length; i++) {
                    const cols = lines[i].split(',');
                    if (cols.length >= 3) {
                        const x = parseInt(cols[0]);
                        const y = parseInt(cols[1]);
                        const depth = parseFloat(cols[2]);
                        
                        if (!isNaN(x) && !isNaN(y) && !isNaN(depth) && depth > 0 && isFinite(depth)) {
                            rawDepthData.push({ x, y, depth, index: rawDepthData.length });
                            minDepth = Math.min(minDepth, depth);
                            maxDepth = Math.max(maxDepth, depth);
                            maxX = Math.max(maxX, x);
                            maxY = Math.max(maxY, y);
                        }
                    }
                }
                
                stats = {
                    pointCount: rawDepthData.length,
                    minDepth: minDepth,
                    maxDepth: maxDepth,
                    imageWidth: maxX + 1,
                    imageHeight: maxY + 1,
                };
                
                updateStatsDisplay();
                resolve();
            });
        }

        function createMetricPointCloud() {
            metricPointCloud = [];
            if (finalPoints.length === 0) return;
            const imageWidth = stats.imageWidth;
            const imageHeight = stats.imageHeight;
            const fov = parseFloat(document.getElementById('cameraFov').value) * (Math.PI / 180);
            const focalLength = (imageWidth / 2) / Math.tan(fov / 2);
            for (const p of finalPoints) {
                const z = p.depth;
                const x = (p.x - imageWidth / 2) * z / focalLength;
                const y = -(p.y - imageHeight / 2) * z / focalLength;
                metricPointCloud.push(new THREE.Vector3(x, y, z));
            }
        }

        function calculateVolume() {
            let volumeM3 = 0;
            if (metricPointCloud.length < 4) {
                updateVolumeDisplay(0);
                updateVoxelStats(0, 0, 0);
                return;
            }
            if (currentMethod === 'voxel') {
                volumeM3 = calculateVoxelVolume();
            }
            updateVolumeDisplay(volumeM3);
        }

        function calculateVoxelVolume() {
            const voxelSize = parseFloat(document.getElementById('voxelSize').value);
            if (voxelSize <= 0) return 0;
            
            const voxelVolume = Math.pow(voxelSize, 3);
            const voxels = new Set();
            
            // Calculate bounding box for the point cloud (safe for large datasets)
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            let minZ = Infinity, maxZ = -Infinity;
            
            for (const point of metricPointCloud) {
                if (point.x < minX) minX = point.x;
                if (point.x > maxX) maxX = point.x;
                if (point.y < minY) minY = point.y;
                if (point.y > maxY) maxY = point.y;
                if (point.z < minZ) minZ = point.z;
                if (point.z > maxZ) maxZ = point.z;
            }
            
            const bounds = { minX, maxX, minY, maxY, minZ, maxZ };
            
            // Calculate grid dimensions
            const gridX = Math.ceil((bounds.maxX - bounds.minX) / voxelSize);
            const gridY = Math.ceil((bounds.maxY - bounds.minY) / voxelSize);
            const gridZ = Math.ceil((bounds.maxZ - bounds.minZ) / voxelSize);
            const totalVoxels = gridX * gridY * gridZ;
            
            // Find occupied voxels
            for (const point of metricPointCloud) {
                const vx = Math.floor((point.x - bounds.minX) / voxelSize);
                const vy = Math.floor((point.y - bounds.minY) / voxelSize);
                const vz = Math.floor((point.z - bounds.minZ) / voxelSize);
                voxels.add(`${vx},${vy},${vz}`);
            }
            
            // Store voxel data for visualization
            voxelData = {
                occupied: voxels,
                bounds: bounds,
                voxelSize: voxelSize,
                gridDimensions: { x: gridX, y: gridY, z: gridZ }
            };
            
            // Update voxel statistics
            updateVoxelStats(voxels.size, totalVoxels, voxelVolume * 1_000_000); // Convert to cm¬≥
            
            return voxels.size * voxelVolume;
        }

        function createVisualizationData() {
            vizPointCloud = [];
            if (metricPointCloud.length === 0) return;
            
            // Calculate bounding box manually for large datasets
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            let minZ = Infinity, maxZ = -Infinity;
            
            for (const point of metricPointCloud) {
                if (point.x < minX) minX = point.x;
                if (point.x > maxX) maxX = point.x;
                if (point.y < minY) minY = point.y;
                if (point.y > maxY) maxY = point.y;
                if (point.z < minZ) minZ = point.z;
                if (point.z > maxZ) maxZ = point.z;
            }
            
            const center = new THREE.Vector3(
                (minX + maxX) / 2,
                (minY + maxY) / 2,
                (minZ + maxZ) / 2
            );
            
            const sizeX = maxX - minX;
            const sizeY = maxY - minY;
            const sizeZ = maxZ - minZ;
            const maxDim = Math.max(sizeX, sizeY, sizeZ);
            
            if (maxDim === 0) return;
            for (const p of metricPointCloud) {
                vizPointCloud.push(p.clone().sub(center).divideScalar(maxDim));
            }
        }
        
        // --- Voxel Visualization Functions ---
        function createVoxelGridVisualization() {
            if (voxelGridLines) {
                scene.remove(voxelGridLines);
                voxelGridLines = null;
            }
            
            if (!voxelData.bounds || voxelData.occupied.size === 0) return;
            
            const { bounds, voxelSize, gridDimensions } = voxelData;
            
            // Create wireframe grid around the object bounds
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            
            // Calculate normalized bounds for visualization manually for large datasets
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            let minZ = Infinity, maxZ = -Infinity;
            
            for (const point of metricPointCloud) {
                if (point.x < minX) minX = point.x;
                if (point.x > maxX) maxX = point.x;
                if (point.y < minY) minY = point.y;
                if (point.y > maxY) maxY = point.y;
                if (point.z < minZ) minZ = point.z;
                if (point.z > maxZ) maxZ = point.z;
            }
            
            const center = new THREE.Vector3(
                (minX + maxX) / 2,
                (minY + maxY) / 2,
                (minZ + maxZ) / 2
            );
            
            const sizeX = maxX - minX;
            const sizeY = maxY - minY;
            const sizeZ = maxZ - minZ;
            const maxDim = Math.max(sizeX, sizeY, sizeZ);
            
            // Convert bounds to visualization space
            const vizBounds = {
                minX: (bounds.minX - center.x) / maxDim,
                maxX: (bounds.maxX - center.x) / maxDim,
                minY: (bounds.minY - center.y) / maxDim,
                maxY: (bounds.maxY - center.y) / maxDim,
                minZ: (bounds.minZ - center.z) / maxDim,
                maxZ: (bounds.maxZ - center.z) / maxDim
            };
            
            const vizVoxelSize = voxelSize / maxDim;
            
            // Create grid lines (sample every few voxels to avoid too many lines)
            const step = Math.max(1, Math.floor(Math.max(gridDimensions.x, gridDimensions.y, gridDimensions.z) / 20));
            
            // X lines
            for (let i = 0; i <= gridDimensions.x; i += step) {
                const x = vizBounds.minX + i * vizVoxelSize;
                vertices.push(x, vizBounds.minY, vizBounds.minZ);
                vertices.push(x, vizBounds.maxY, vizBounds.minZ);
                vertices.push(x, vizBounds.minY, vizBounds.maxZ);
                vertices.push(x, vizBounds.maxY, vizBounds.maxZ);
                vertices.push(x, vizBounds.minY, vizBounds.minZ);
                vertices.push(x, vizBounds.minY, vizBounds.maxZ);
                vertices.push(x, vizBounds.maxY, vizBounds.minZ);
                vertices.push(x, vizBounds.maxY, vizBounds.maxZ);
            }
            
            // Y lines
            for (let i = 0; i <= gridDimensions.y; i += step) {
                const y = vizBounds.minY + i * vizVoxelSize;
                vertices.push(vizBounds.minX, y, vizBounds.minZ);
                vertices.push(vizBounds.maxX, y, vizBounds.minZ);
                vertices.push(vizBounds.minX, y, vizBounds.maxZ);
                vertices.push(vizBounds.maxX, y, vizBounds.maxZ);
                vertices.push(vizBounds.minX, y, vizBounds.minZ);
                vertices.push(vizBounds.minX, y, vizBounds.maxZ);
                vertices.push(vizBounds.maxX, y, vizBounds.minZ);
                vertices.push(vizBounds.maxX, y, vizBounds.maxZ);
            }
            
            // Z lines
            for (let i = 0; i <= gridDimensions.z; i += step) {
                const z = vizBounds.minZ + i * vizVoxelSize;
                vertices.push(vizBounds.minX, vizBounds.minY, z);
                vertices.push(vizBounds.maxX, vizBounds.minY, z);
                vertices.push(vizBounds.minX, vizBounds.maxY, z);
                vertices.push(vizBounds.maxX, vizBounds.maxY, z);
                vertices.push(vizBounds.minX, vizBounds.minY, z);
                vertices.push(vizBounds.minX, vizBounds.maxY, z);
                vertices.push(vizBounds.maxX, vizBounds.minY, z);
                vertices.push(vizBounds.maxX, vizBounds.maxY, z);
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(vertices), 3));
            
            const material = new THREE.LineBasicMaterial({ 
                color: 0x333333, 
                transparent: true, 
                opacity: 0.3 
            });
            
            voxelGridLines = new THREE.LineSegments(geometry, material);
            scene.add(voxelGridLines);
        }
        
        function createOccupiedVoxelsVisualization() {
            if (occupiedVoxelsGroup) {
                scene.remove(occupiedVoxelsGroup);
                occupiedVoxelsGroup = null;
            }
            
            if (!voxelData.bounds || voxelData.occupied.size === 0) return;
            
            const { bounds, voxelSize, occupied } = voxelData;
            
            // Calculate normalization parameters manually for large datasets
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            let minZ = Infinity, maxZ = -Infinity;
            
            for (const point of metricPointCloud) {
                if (point.x < minX) minX = point.x;
                if (point.x > maxX) maxX = point.x;
                if (point.y < minY) minY = point.y;
                if (point.y > maxY) maxY = point.y;
                if (point.z < minZ) minZ = point.z;
                if (point.z > maxZ) maxZ = point.z;
            }
            
            const center = new THREE.Vector3(
                (minX + maxX) / 2,
                (minY + maxY) / 2,
                (minZ + maxZ) / 2
            );
            
            const sizeX = maxX - minX;
            const sizeY = maxY - minY;
            const sizeZ = maxZ - minZ;
            const maxDim = Math.max(sizeX, sizeY, sizeZ);
            
            const vizVoxelSize = voxelSize / maxDim;
            
            // Create instanced mesh for better performance
            const voxelGeometry = new THREE.BoxGeometry(vizVoxelSize, vizVoxelSize, vizVoxelSize);
            const voxelMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x4facfe, 
                transparent: true, 
                opacity: parseFloat(document.getElementById('voxelOpacity').value)
            });
            
            occupiedVoxelsGroup = new THREE.Group();
            
            // Sample occupied voxels if there are too many (for performance)
            const maxVoxelsToShow = 2000;
            const occupiedArray = Array.from(occupied);
            const step = Math.max(1, Math.floor(occupiedArray.length / maxVoxelsToShow));
            
            for (let i = 0; i < occupiedArray.length; i += step) {
                const coords = occupiedArray[i].split(',').map(Number);
                const vx = coords[0];
                const vy = coords[1];
                const vz = coords[2];
                
                // Convert to metric coordinates
                const x = bounds.minX + (vx + 0.5) * voxelSize;
                const y = bounds.minY + (vy + 0.5) * voxelSize;
                const z = bounds.minZ + (vz + 0.5) * voxelSize;
                
                // Convert to visualization coordinates
                const vizX = (x - center.x) / maxDim;
                const vizY = (y - center.y) / maxDim;
                const vizZ = (z - center.z) / maxDim;
                
                const voxelMesh = new THREE.Mesh(voxelGeometry, voxelMaterial);
                voxelMesh.position.set(vizX, vizY, vizZ);
                occupiedVoxelsGroup.add(voxelMesh);
            }
            
            scene.add(occupiedVoxelsGroup);
        }
        
        function updateVisualization() {
            if (scene) {
                if (pointCloud) scene.remove(pointCloud);
                if (meshSurface) scene.remove(meshSurface);
                if (voxelGridLines) scene.remove(voxelGridLines);
                if (occupiedVoxelsGroup) scene.remove(occupiedVoxelsGroup);
            }
            if (vizPointCloud.length === 0) {
                renderer.render(scene, camera);
                return;
            };
            if (document.getElementById('showPointCloud').checked) createPointCloudVisualization();
            if (document.getElementById('showMesh').checked) createMeshVisualization();
            if (document.getElementById('showVoxelGrid').checked) createVoxelGridVisualization();
            if (document.getElementById('showOccupiedVoxels').checked) createOccupiedVoxelsVisualization();
        }

        function createPointCloudVisualization() {
            const geometry = new THREE.BufferGeometry().setFromPoints(vizPointCloud);
            const material = new THREE.PointsMaterial({
                size: parseFloat(document.getElementById('pointSize').value),
                sizeAttenuation: false,
                color: 0x4facfe
            });
            pointCloud = new THREE.Points(geometry, material);
            scene.add(pointCloud);
        }
        
        function createMeshVisualization() {
            const geometry = new THREE.BufferGeometry().setFromPoints(vizPointCloud);
            const material = new THREE.MeshLambertMaterial({
                color: 0x00f2fe,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.8
            });
            meshSurface = new THREE.Mesh(geometry, material);
            scene.add(meshSurface);
        }

        function showLoading(show, text = 'Processing...') {
            document.getElementById('loading').style.display = show ? 'block' : 'none';
            document.getElementById('loadingText').textContent = text;
        }

        function updateProgress(percent) {
            document.getElementById('progressFill').style.width = percent + '%';
        }

        function showUI() {
            document.getElementById('statsSection').style.display = 'block';
            document.getElementById('vizSection').style.display = 'block';
            document.getElementById('volumeSection').style.display = 'block';
            document.getElementById('segmentationSection').style.display = 'block';
            document.getElementById('advancedSection').style.display = 'block';
        }

        function updateStatsDisplay() {
            const grid = document.getElementById('statsGrid');
            grid.innerHTML = `
                <div class="stat-item"><div class="stat-value">${stats.pointCount.toLocaleString()}</div><div class="stat-label">Raw Points</div></div>
                <div class="stat-item"><div class="stat-value">${stats.imageWidth}√ó${stats.imageHeight}</div><div class="stat-label">Sensor Resolution</div></div>
                <div class="stat-item"><div class="stat-value">${stats.minDepth.toFixed(3)}m</div><div class="stat-label">Min Depth</div></div>
                <div class="stat-item"><div class="stat-value">${stats.maxDepth.toFixed(3)}m</div><div class="stat-label">Max Depth</div></div>
            `;
        }

        function updateVolumeDisplay(volumeM3) {
            const volumeCm3 = volumeM3 * 1_000_000;
            const result = document.getElementById('volumeResult');
            result.innerHTML = `Volume: ${volumeCm3.toLocaleString(undefined, {maximumFractionDigits: 2})} cm¬≥`;
        }
        
        function updateVoxelStats(occupiedCount, totalCount, voxelVolumeCm3) {
            const statsElement = document.getElementById('voxelStats');
            if (occupiedCount > 0) {
                statsElement.style.display = 'block';
                document.getElementById('occupiedVoxels').textContent = occupiedCount.toLocaleString();
                document.getElementById('totalVoxels').textContent = totalCount.toLocaleString();
                document.getElementById('voxelVolume').textContent = voxelVolumeCm3.toFixed(6);
                document.getElementById('occupancyRate').textContent = ((occupiedCount / totalCount) * 100).toFixed(2) + '%';
            } else {
                statsElement.style.display = 'none';
            }
        }

        function setupBasicControls() {
            let isMouseDown = false;
            let prevMouseX = 0, prevMouseY = 0;
            const canvas = renderer.domElement;
            
            canvas.addEventListener('mousedown', e => { 
                if (isDrawingMode) return;
                isMouseDown = true; 
                prevMouseX = e.clientX; 
                prevMouseY = e.clientY; 
            });
            canvas.addEventListener('mouseup', () => isMouseDown = false);
            canvas.addEventListener('mouseout', () => isMouseDown = false);
            canvas.addEventListener('mousemove', e => {
                if (!isMouseDown || isDrawingMode) return;
                const deltaX = e.clientX - prevMouseX;
                const deltaY = e.clientY - prevMouseY;
                scene.rotation.y += deltaX * 0.005;
                scene.rotation.x += deltaY * 0.005;
                prevMouseX = e.clientX;
                prevMouseY = e.clientY;
            });
            canvas.addEventListener('wheel', e => { 
                if (isDrawingMode) return;
                camera.position.z *= (e.deltaY > 0 ? 1.1 : 0.9); 
            }, { passive: true });
        }

        function onWindowResize() {
            const container = document.querySelector('.main-view');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
            
            // Update drawing canvas size
            if (drawingCanvas) {
                drawingCanvas.width = container.clientWidth;
                drawingCanvas.height = container.clientHeight;
                if (isDrawingMode && rawDepthData.length > 0) {
                    showDepthVisualization();
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        // --- Event Listeners ---
        document.getElementById('csvFile').addEventListener('change', handleFileUpload);
        
        // Drawing controls
        document.getElementById('enableDrawingBtn').addEventListener('click', () => {
            if (rawDepthData.length === 0) {
                alert('Please upload a CSV file first.');
                return;
            }
            
            if (isDrawingMode) {
                disableDrawingMode();
            } else {
                enableDrawingMode();
            }
        });

        document.getElementById('clearDrawingBtn').addEventListener('click', clearDrawing);
        document.getElementById('applySegmentationBtn').addEventListener('click', applySegmentation);

        // Drawing overlay controls
        document.getElementById('toggleDrawBtn').addEventListener('click', () => {
            // Toggle drawing functionality here if needed
        });

        document.getElementById('clearBtn').addEventListener('click', clearDrawing);
        document.getElementById('doneBtn').addEventListener('click', disableDrawingMode);

        const recalcControls = ['voxelSize', 'cameraFov'];
        recalcControls.forEach(id => {
            document.getElementById(id).addEventListener('change', () => {
                if(finalPoints.length > 0) calculateAndVisualize();
            });
        });

        document.getElementById('pointSize').addEventListener('input', e => {
            document.getElementById('pointSizeValue').textContent = e.target.value;
            if (pointCloud) pointCloud.material.size = parseFloat(e.target.value);
        });
        document.getElementById('voxelSize').addEventListener('input', e => {
            document.getElementById('voxelSizeValue').textContent = e.target.value;
        });
        document.getElementById('cameraFov').addEventListener('input', e => {
            document.getElementById('fovValue').textContent = e.target.value;
        });
        document.getElementById('voxelOpacity').addEventListener('input', e => {
            document.getElementById('voxelOpacityValue').textContent = e.target.value;
            if (occupiedVoxelsGroup) {
                occupiedVoxelsGroup.children.forEach(voxel => {
                    voxel.material.opacity = parseFloat(e.target.value);
                });
            }
        });
        
        document.getElementById('showPointCloud').addEventListener('change', updateVisualization);
        document.getElementById('showMesh').addEventListener('change', updateVisualization);
        document.getElementById('showVoxelGrid').addEventListener('change', updateVisualization);
        document.getElementById('showOccupiedVoxels').addEventListener('change', updateVisualization);

        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', (e) => {
                const newMethod = e.target.dataset.method;
                if(newMethod === 'voxel') {
                    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                    e.target.classList.add('active');
                    currentMethod = newMethod;
                    if (finalPoints.length > 0) calculateVolume();
                } else {
                    alert("Only the Voxel method is implemented in this version.");
                }
            });
        });
        
        // Initialize
        initThreeJS();
        
        // Initialize drawing canvas when DOM is ready
        window.addEventListener('load', () => {
            initDrawingCanvas();
        });
    </script>
</body>
</html>