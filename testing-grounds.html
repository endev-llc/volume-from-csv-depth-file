<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cubic Voxel Volume Analyzer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            color: white;
            overflow: hidden;
        }

        .app-container {
            display: grid;
            grid-template-columns: 350px 1fr;
            height: 100vh;
        }

        .control-panel {
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(15px);
            border-right: 1px solid rgba(255, 255, 255, 0.1);
            padding: 20px;
            overflow-y: auto;
            z-index: 100;
        }

        .viewer-container {
            position: relative;
            background: #000;
            overflow: hidden;
        }

        .app-title {
            font-size: 22px;
            font-weight: bold;
            margin-bottom: 25px;
            background: linear-gradient(45deg, #00d4ff, #ff6b6b);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-align: center;
        }

        .section {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 18px;
            margin-bottom: 20px;
            transition: all 0.3s ease;
        }

        .section:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(0, 212, 255, 0.3);
        }

        .section-title {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 15px;
            color: #00d4ff;
        }

        .upload-area {
            border: 2px dashed #00d4ff;
            border-radius: 10px;
            padding: 25px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: rgba(0, 212, 255, 0.05);
        }

        .upload-area:hover {
            background: rgba(0, 212, 255, 0.1);
            border-color: #ff6b6b;
        }

        .upload-area.dragover {
            background: rgba(0, 212, 255, 0.15);
            border-color: #ff6b6b;
        }

        input[type="file"] {
            display: none;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-label {
            display: block;
            margin-bottom: 8px;
            font-size: 14px;
            color: #ccc;
        }

        .value-display {
            background: rgba(0, 0, 0, 0.4);
            padding: 4px 8px;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: #00d4ff;
        }

        input[type="range"] {
            width: 100%;
            margin: 8px 0;
            accent-color: #00d4ff;
        }

        .btn {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 10px;
            font-size: 14px;
        }

        .btn-primary {
            background: linear-gradient(45deg, #00d4ff, #0099cc);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 212, 255, 0.4);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .btn-danger {
            background: linear-gradient(45deg, #ff6b6b, #ee5a52);
            color: white;
        }

        .btn-danger:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(255, 107, 107, 0.4);
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 12px;
        }

        input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: #00d4ff;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-bottom: 15px;
        }

        .stat-card {
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-value {
            font-size: 18px;
            font-weight: bold;
            color: #00d4ff;
        }

        .stat-label {
            font-size: 11px;
            color: #aaa;
            margin-top: 4px;
        }

        .volume-display {
            background: linear-gradient(45deg, #00d4ff, #ff6b6b);
            color: black;
            padding: 20px;
            border-radius: 12px;
            text-align: center;
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 20px;
            box-shadow: 0 4px 20px rgba(0, 212, 255, 0.3);
        }

        .voxel-info {
            background: rgba(0, 212, 255, 0.1);
            border: 1px solid rgba(0, 212, 255, 0.3);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .voxel-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 10px;
        }

        .voxel-stat {
            text-align: center;
        }

        .voxel-stat-value {
            font-size: 16px;
            font-weight: bold;
            color: #00d4ff;
        }

        .voxel-stat-label {
            font-size: 10px;
            color: #bbb;
        }

        .progress-bar {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00d4ff, #ff6b6b);
            width: 0%;
            transition: width 0.3s ease;
        }

        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .loading-content {
            text-align: center;
            color: white;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid rgba(0, 212, 255, 0.3);
            border-left: 4px solid #00d4ff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .drawing-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 50;
        }

        .drawing-overlay.active {
            pointer-events: all;
            cursor: crosshair;
        }

        .drawing-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            display: none;
            flex-direction: column;
            gap: 10px;
            z-index: 60;
        }

        .draw-btn {
            padding: 10px 15px;
            border: none;
            border-radius: 8px;
            background: rgba(0, 212, 255, 0.9);
            color: black;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .draw-btn:hover {
            transform: scale(1.05);
        }

        .draw-btn.active {
            background: #ff6b6b;
            color: white;
        }

        .mode-indicator {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 14px;
            z-index: 60;
        }

        #canvas3d {
            display: block;
            width: 100%;
            height: 100%;
        }

        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <div class="control-panel">
            <div class="app-title">🧊 Cubic Voxel Analyzer</div>
            
            <div class="section">
                <div class="section-title">📂 Data Import</div>
                <div class="upload-area" id="uploadArea">
                    <div style="font-size: 18px; margin-bottom: 10px;">📊</div>
                    <div>Drop CSV file here or click to browse</div>
                    <div style="font-size: 12px; color: #aaa; margin-top: 8px;">
                        Supports files up to 4MB
                    </div>
                </div>
                <input type="file" id="fileInput" accept=".csv">
                <div class="progress-bar">
                    <div class="progress-fill" id="progressBar"></div>
                </div>
            </div>

            <div class="section hidden" id="statsSection">
                <div class="section-title">📊 Dataset Statistics</div>
                <div class="stats-grid" id="statsGrid"></div>
            </div>

            <div class="section hidden" id="isolationSection">
                <div class="section-title">✏️ Object Isolation</div>
                <button class="btn btn-primary" id="startDrawBtn">Start Drawing</button>
                <button class="btn btn-secondary" id="clearDrawBtn">Clear Drawing</button>
                <button class="btn btn-danger" id="applyIsolationBtn">Apply Isolation</button>
                <div class="control-group">
                    <span class="control-label">Selected Points: <span class="value-display" id="selectedCount">0</span></span>
                </div>
            </div>

            <div class="section hidden" id="voxelSection">
                <div class="section-title">🧊 Voxel Configuration</div>
                <div class="control-group">
                    <label class="control-label">
                        Voxel Size: <span class="value-display" id="voxelSizeValue">0.005</span>m
                    </label>
                    <input type="range" id="voxelSize" min="0.001" max="0.02" step="0.001" value="0.005">
                </div>
                <div class="control-group">
                    <label class="control-label">
                        Camera FOV: <span class="value-display" id="fovValue">75</span>°
                    </label>
                    <input type="range" id="cameraFov" min="30" max="90" step="1" value="75">
                </div>
                <button class="btn btn-primary" id="generateVoxelsBtn">Generate Voxels</button>
            </div>

            <div class="section hidden" id="volumeSection">
                <div class="section-title">📏 Volume Analysis</div>
                <div class="volume-display" id="volumeDisplay">
                    Volume: 0 cm³
                </div>
                <div class="voxel-info">
                    <div style="font-weight: bold; margin-bottom: 10px;">Voxel Analysis</div>
                    <div class="voxel-grid">
                        <div class="voxel-stat">
                            <div class="voxel-stat-value" id="filledVoxels">0</div>
                            <div class="voxel-stat-label">Filled Voxels</div>
                        </div>
                        <div class="voxel-stat">
                            <div class="voxel-stat-value" id="totalVoxels">0</div>
                            <div class="voxel-stat-label">Total Grid</div>
                        </div>
                        <div class="voxel-stat">
                            <div class="voxel-stat-value" id="voxelVolumeStat">0</div>
                            <div class="voxel-stat-label">Per Voxel (mm³)</div>
                        </div>
                        <div class="voxel-stat">
                            <div class="voxel-stat-value" id="fillRatio">0%</div>
                            <div class="voxel-stat-label">Fill Ratio</div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="section hidden" id="visualSection">
                <div class="section-title">👁️ Visualization</div>
                <div class="checkbox-group">
                    <input type="checkbox" id="showPoints" checked>
                    <label>Point Cloud</label>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="showVoxels" checked>
                    <label>Cubic Voxels</label>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="showWireframe">
                    <label>Voxel Wireframe</label>
                </div>
                <div class="control-group">
                    <label class="control-label">
                        Point Size: <span class="value-display" id="pointSizeValue">2</span>
                    </label>
                    <input type="range" id="pointSize" min="1" max="8" step="1" value="2">
                </div>
                <div class="control-group">
                    <label class="control-label">
                        Voxel Opacity: <span class="value-display" id="voxelOpacityValue">0.7</span>
                    </label>
                    <input type="range" id="voxelOpacity" min="0.1" max="1.0" step="0.1" value="0.7">
                </div>
            </div>
        </div>

        <div class="viewer-container">
            <canvas id="canvas3d"></canvas>
            
            <div class="drawing-overlay" id="drawingOverlay">
                <canvas id="drawingCanvas"></canvas>
            </div>

            <div class="drawing-controls" id="drawingControls">
                <button class="draw-btn" id="finishDrawBtn">Finish</button>
                <button class="draw-btn" id="cancelDrawBtn">Cancel</button>
            </div>

            <div class="mode-indicator" id="modeIndicator">3D Navigation Mode</div>

            <div class="loading-overlay" id="loadingOverlay">
                <div class="loading-content">
                    <div class="spinner"></div>
                    <div id="loadingText">Processing...</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let scene, camera, renderer, controls;
        let pointCloudMesh = null;
        let voxelMesh = null;
        let wireframeMesh = null;

        // Data storage - NOW STORES BOTH DEPTH VALUES
        let rawDepthData = [];
        let isolatedData = [];
        let pointCloud3D = [];
        let pointCloud3DForVolume = []; // New: stores point cloud using raw depth for volume
        let voxelGrid = new Map();
        let filledVoxelGrid = new Map();

        // Drawing state
        let isDrawingMode = false;
        let isCurrentlyDrawing = false;
        let drawingPath = [];
        let drawingCanvas, drawingContext;

        // Statistics
        let dataStats = {};
        let voxelStats = {};

        // Initialize the application
        function init() {
            setupThreeJS();
            setupDrawingCanvas();
            setupEventListeners();
            setupFileUpload();
        }

        function setupThreeJS() {
            const canvas = document.getElementById('canvas3d');
            const container = canvas.parentElement;

            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0a);

            // Camera setup
            camera = new THREE.PerspectiveCamera(
                75, 
                container.clientWidth / container.clientHeight, 
                0.001, 
                100
            );
            camera.position.set(0.5, 0.5, 0.5);
            camera.lookAt(0, 0, 0);

            // Renderer setup
            renderer = new THREE.WebGLRenderer({ 
                canvas: canvas, 
                antialias: true,
                alpha: true 
            });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 5, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            // Controls
            setupControls();

            // Start render loop
            animate();

            // Handle window resize
            window.addEventListener('resize', onWindowResize);
        }

        function setupDrawingCanvas() {
            drawingCanvas = document.getElementById('drawingCanvas');
            drawingContext = drawingCanvas.getContext('2d');
            
            const container = document.querySelector('.viewer-container');
            drawingCanvas.width = container.clientWidth;
            drawingCanvas.height = container.clientHeight;

            // Drawing events
            drawingCanvas.addEventListener('mousedown', startDrawing);
            drawingCanvas.addEventListener('mousemove', draw);
            drawingCanvas.addEventListener('mouseup', stopDrawing);
            drawingCanvas.addEventListener('touchstart', handleTouch);
            drawingCanvas.addEventListener('touchmove', handleTouch);
            drawingCanvas.addEventListener('touchend', stopDrawing);
        }

        function setupControls() {
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };

            const canvas = renderer.domElement;

            canvas.addEventListener('mousedown', (e) => {
                if (isDrawingMode) return;
                isDragging = true;
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });

            canvas.addEventListener('mousemove', (e) => {
                if (!isDragging || isDrawingMode) return;

                const deltaMove = {
                    x: e.clientX - previousMousePosition.x,
                    y: e.clientY - previousMousePosition.y
                };

                const rotationSpeed = 0.005;
                scene.rotation.y += deltaMove.x * rotationSpeed;
                scene.rotation.x += deltaMove.y * rotationSpeed;

                previousMousePosition = { x: e.clientX, y: e.clientY };
            });

            canvas.addEventListener('mouseup', () => {
                isDragging = false;
            });

            canvas.addEventListener('wheel', (e) => {
                if (isDrawingMode) return;
                const zoomSpeed = 0.1;
                camera.position.multiplyScalar(e.deltaY > 0 ? 1 + zoomSpeed : 1 - zoomSpeed);
            }, { passive: true });
        }

        function setupFileUpload() {
            const uploadArea = document.getElementById('uploadArea');
            const fileInput = document.getElementById('fileInput');

            uploadArea.addEventListener('click', () => fileInput.click());
            uploadArea.addEventListener('dragover', handleDragOver);
            uploadArea.addEventListener('drop', handleDrop);
            fileInput.addEventListener('change', handleFileSelect);
        }

        function setupEventListeners() {
            // Drawing controls
            document.getElementById('startDrawBtn').addEventListener('click', startDrawingMode);
            document.getElementById('clearDrawBtn').addEventListener('click', clearDrawing);
            document.getElementById('applyIsolationBtn').addEventListener('click', applyIsolation);

            // Voxel controls
            document.getElementById('generateVoxelsBtn').addEventListener('click', generateVoxels);

            // Visualization controls
            document.getElementById('showPoints').addEventListener('change', updateVisualization);
            document.getElementById('showVoxels').addEventListener('change', updateVisualization);
            document.getElementById('showWireframe').addEventListener('change', updateVisualization);

            // Range inputs
            document.getElementById('voxelSize').addEventListener('input', updateVoxelSizeDisplay);
            document.getElementById('cameraFov').addEventListener('input', updateFovDisplay);
            document.getElementById('pointSize').addEventListener('input', updatePointSizeDisplay);
            document.getElementById('voxelOpacity').addEventListener('input', updateVoxelOpacityDisplay);

            // Drawing overlay controls
            document.getElementById('finishDrawBtn').addEventListener('click', finishDrawing);
            document.getElementById('cancelDrawBtn').addEventListener('click', cancelDrawing);
        }

        // File handling
        function handleDragOver(e) {
            e.preventDefault();
            document.getElementById('uploadArea').classList.add('dragover');
        }

        function handleDrop(e) {
            e.preventDefault();
            document.getElementById('uploadArea').classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                processFile(files[0]);
            }
        }

        function handleFileSelect(e) {
            const file = e.target.files[0];
            if (file) {
                processFile(file);
            }
        }

        async function processFile(file) {
            if (!file.name.toLowerCase().endsWith('.csv')) {
                alert('Please select a CSV file.');
                return;
            }

            showLoading(true, 'Reading file...');
            updateProgress(0);

            try {
                const text = await file.text();
                updateProgress(25);

                await parseCSVData(text);
                updateProgress(50);

                createPointCloud();
                updateProgress(75);

                updateDataStats();
                showSections(['statsSection', 'isolationSection', 'voxelSection', 'visualSection']);
                updateProgress(100);

                setTimeout(() => showLoading(false), 500);

            } catch (error) {
                console.error('Error processing file:', error);
                alert('Error processing file. Please check the format.');
                showLoading(false);
            }
        }

        async function parseCSVData(text) {
            return new Promise((resolve) => {
                const lines = text.trim().split('\n');
                rawDepthData = [];
                
                let minDepth = Infinity, maxDepth = -Infinity;
                let minX = Infinity, maxX = -Infinity;
                let minY = Infinity, maxY = -Infinity;

                // Skip header if present
                const startLine = lines[0].includes(',') && isNaN(parseFloat(lines[0].split(',')[0])) ? 1 : 0;

                // Check if we have 4 columns (dual depth format) or 3 columns (single depth)
                const testLine = lines[startLine].split(',');
                const hasDualDepth = testLine.length >= 4;

                // First, read all valid points so we know the range
                const allPoints = [];
                for (let i = startLine; i < lines.length; i++) {
                    const cols = lines[i].split(',');
                    if (cols.length >= 3) {
                        const x = parseFloat(cols[0]);
                        const y = parseFloat(cols[1]);
                        const depthRaw = parseFloat(cols[2]);
                        // Use geometry depth if available (4th column), otherwise use raw depth
                        const depthGeometry = hasDualDepth && cols.length >= 4 ? 
                            parseFloat(cols[3]) : depthRaw;
                        
                        if (!isNaN(x) && !isNaN(y) && !isNaN(depthRaw) && depthRaw > 0) {
                            allPoints.push({ 
                                x, 
                                y, 
                                depth: depthGeometry,  // For rendering (geometry-corrected)
                                depthRaw: depthRaw     // For volume calculations (accurate)
                            });
                            // Use geometry depth for display statistics
                            minDepth = Math.min(minDepth, depthGeometry);
                            maxDepth = Math.max(maxDepth, depthGeometry);
                            minX = Math.min(minX, x);
                            maxX = Math.max(maxX, x);
                            minY = Math.min(minY, y);
                            maxY = Math.max(maxY, y);
                        }
                    }
                }

                // Determine the cutoff X for top 10% (now using X axis for vertical cropping)
                const cropThresholdX = minX + (maxX - minX) * 0.10;

                // Keep only points below the crop line (i.e., remove top 10% in X direction)
                rawDepthData = allPoints.filter(p => p.x > cropThresholdX);

                dataStats = {
                    pointCount: rawDepthData.length,
                    minDepth, maxDepth,
                    minX: cropThresholdX, maxX,
                    minY, maxY,
                    imageWidth: maxX - cropThresholdX + 1,
                    imageHeight: maxY - minY + 1,
                    hasDualDepth: hasDualDepth
                };

                console.log(`Loaded ${hasDualDepth ? 'dual-depth' : 'single-depth'} CSV format`);
                resolve();
            });
        }

        function createPointCloud() {
            // Convert 2D depth data to 3D coordinates (absolute metric coordinates)
            pointCloud3D = [];
            pointCloud3DForVolume = [];
            const fov = parseFloat(document.getElementById('cameraFov').value) * (Math.PI / 180);
            const focalLength = (dataStats.imageWidth / 2) / Math.tan(fov / 2);

            for (const point of rawDepthData) {
                // For rendering - use geometry-corrected depth
                const z = point.depth;
                const x = (point.x - dataStats.imageWidth / 2) * z / focalLength;
                const y = -(point.y - dataStats.imageHeight / 2) * z / focalLength;
                pointCloud3D.push(new THREE.Vector3(x, y, z));
                
                // For volume calculation - use raw accurate depth
                const zRaw = point.depthRaw;
                const xRaw = (point.x - dataStats.imageWidth / 2) * zRaw / focalLength;
                const yRaw = -(point.y - dataStats.imageHeight / 2) * zRaw / focalLength;
                pointCloud3DForVolume.push(new THREE.Vector3(xRaw, yRaw, zRaw));
            }

            // Center the point cloud but preserve absolute scale
            centerPointCloud();
            
            // Adjust camera to view the object at appropriate distance
            adjustCameraForObject();
            
            updateVisualization();
        }

        function centerPointCloud() {
            if (pointCloud3D.length === 0) return;

            // Calculate center point for rendering cloud
            const bbox = new THREE.Box3().setFromPoints(pointCloud3D);
            const center = bbox.getCenter(new THREE.Vector3());

            // Center both point clouds
            for (let i = 0; i < pointCloud3D.length; i++) {
                pointCloud3D[i].sub(center);
            }
            
            // Also center the volume calculation cloud
            const bboxVolume = new THREE.Box3().setFromPoints(pointCloud3DForVolume);
            const centerVolume = bboxVolume.getCenter(new THREE.Vector3());
            for (let i = 0; i < pointCloud3DForVolume.length; i++) {
                pointCloud3DForVolume[i].sub(centerVolume);
            }
        }

        function adjustCameraForObject() {
            if (pointCloud3D.length === 0) return;

            // Calculate bounding box of centered object (use rendering cloud)
            const bbox = new THREE.Box3().setFromPoints(pointCloud3D);
            const size = bbox.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);

            // Position camera at appropriate distance to view the object
            // Use a multiplier to ensure the object is nicely framed
            const distance = maxDim * 2.5;
            camera.position.set(distance * 0.7, distance * 0.7, distance * 0.7);
            camera.lookAt(0, 0, 0);

            // Update axes helper size to be proportional to object
            updateAxesHelper(maxDim * 0.3);
        }

        function updateAxesHelper(size) {
            // Remove old axes helper
            const oldAxes = scene.getObjectByName('axesHelper');
            if (oldAxes) {
                scene.remove(oldAxes);
            }

            // Add new appropriately sized axes helper
            const axesHelper = new THREE.AxesHelper(size);
            axesHelper.name = 'axesHelper';
            scene.add(axesHelper);
        }

        // Drawing functionality
        function startDrawingMode() {
            if (rawDepthData.length === 0) {
                alert('Please upload a CSV file first.');
                return;
            }

            isDrawingMode = true;
            document.getElementById('drawingOverlay').classList.add('active');
            document.getElementById('drawingControls').style.display = 'flex';
            document.getElementById('modeIndicator').textContent = 'Drawing Mode - Outline the object';
            document.getElementById('startDrawBtn').textContent = 'Exit Drawing';
            
            // Show depth visualization for easier drawing
            showDepthVisualization();
        }

        function showDepthVisualization() {
            const canvas = drawingCanvas;
            const ctx = drawingContext;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (rawDepthData.length === 0) return;

            // Calculate min/max depth from the currently displayed data for better color contrast
            let displayMinDepth = Infinity;
            let displayMaxDepth = -Infinity;
            for (const point of rawDepthData) {
                // Use geometry depth for visualization
                if (point.depth < displayMinDepth) displayMinDepth = point.depth;
                if (point.depth > displayMaxDepth) displayMaxDepth = point.depth;
            }

            // Calculate scale to fit canvas
            const scaleX = canvas.width / dataStats.imageWidth;
            const scaleY = canvas.height / dataStats.imageHeight;
            const scale = Math.min(scaleX, scaleY);
            
            const offsetX = (canvas.width - dataStats.imageWidth * scale) / 2;
            const offsetY = (canvas.height - dataStats.imageHeight * scale) / 2;

            const depthRange = displayMaxDepth - displayMinDepth;

            // Draw depth points
            ctx.save();
            for (const point of rawDepthData) {
                const x = offsetX + point.x * scale;
                const y = offsetY + point.y * scale;
                
                // Normalize depth based on the local range to ensure full color spectrum is used
                const normalizedDepth = depthRange > 0 
                    ? (point.depth - displayMinDepth) / depthRange
                    : 0.5;

                // Map normalized depth to a hue value in the HSL color space.
                // We'll map it from blue (240) for close points to red (0) for far points.
                const hue = (1 - normalizedDepth) * 240; 
                
                // Use HSL for a vibrant, easily distinguishable color map.
                ctx.fillStyle = `hsl(${hue}, 100%, 50%)`;
                ctx.fillRect(Math.floor(x), Math.floor(y), Math.ceil(scale), Math.ceil(scale));
            }
            ctx.restore();
        }

        function startDrawing(e) {
            if (!isDrawingMode) return;
            
            isCurrentlyDrawing = true;
            drawingPath = [];
            
            const rect = drawingCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            drawingPath.push({ x, y });
            
            drawingContext.beginPath();
            drawingContext.moveTo(x, y);
            drawingContext.strokeStyle = '#ff6b6b';
            drawingContext.lineWidth = 3;
            drawingContext.lineCap = 'round';
        }

        function draw(e) {
            if (!isDrawingMode || !isCurrentlyDrawing) return;
            
            const rect = drawingCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            drawingPath.push({ x, y });
            
            drawingContext.lineTo(x, y);
            drawingContext.stroke();
        }

        function stopDrawing() {
            if (!isCurrentlyDrawing) return;
            
            isCurrentlyDrawing = false;
            
            if (drawingPath.length > 2) {
                drawingContext.closePath();
                drawingContext.stroke();
            }
        }

        function handleTouch(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent(
                e.type === 'touchstart' ? 'mousedown' : 
                e.type === 'touchmove' ? 'mousemove' : 'mouseup', 
                {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                }
            );
            drawingCanvas.dispatchEvent(mouseEvent);
        }

        function clearDrawing() {
            drawingContext.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
            drawingPath = [];
            isCurrentlyDrawing = false;
            document.getElementById('selectedCount').textContent = '0';
            
            if (isDrawingMode) {
                showDepthVisualization();
            }
        }

        function finishDrawing() {
            applyIsolation();
        }

        function cancelDrawing() {
            isDrawingMode = false;
            isCurrentlyDrawing = false;
            document.getElementById('drawingOverlay').classList.remove('active');
            document.getElementById('drawingControls').style.display = 'none';
            document.getElementById('modeIndicator').textContent = '3D Navigation Mode';
            document.getElementById('startDrawBtn').textContent = 'Start Drawing';
            clearDrawing();
        }

        async function applyIsolation() {
            if (drawingPath.length < 3) {
                alert('Please draw a complete outline around the object.');
                return;
            }

            showLoading(true, 'Applying isolation...');

            // Convert drawing coordinates to data coordinates
            const canvas = drawingCanvas;
            const scaleX = canvas.width / dataStats.imageWidth;
            const scaleY = canvas.height / dataStats.imageHeight;
            const scale = Math.min(scaleX, scaleY);
            
            const offsetX = (canvas.width - dataStats.imageWidth * scale) / 2;
            const offsetY = (canvas.height - dataStats.imageHeight * scale) / 2;
            
            const dataSpacePath = drawingPath.map(p => ({
                x: (p.x - offsetX) / scale,
                y: (p.y - offsetY) / scale
            }));

            // Filter points inside the drawn polygon
            isolatedData = rawDepthData.filter(point => {
                return pointInPolygon(point, dataSpacePath);
            });

            document.getElementById('selectedCount').textContent = isolatedData.length.toLocaleString();

            if (isolatedData.length === 0) {
                alert('No points found in selected area. Try drawing a larger selection.');
                showLoading(false);
                return;
            }

            // Update point cloud with isolated data
            await updatePointCloudFromIsolated();
            
            cancelDrawing();
            showLoading(false);
        }

        async function updatePointCloudFromIsolated() {
            // Convert isolated 2D data to 3D (absolute metric coordinates)
            pointCloud3D = [];
            pointCloud3DForVolume = [];
            const fov = parseFloat(document.getElementById('cameraFov').value) * (Math.PI / 180);
            const focalLength = (dataStats.imageWidth / 2) / Math.tan(fov / 2);

            for (const point of isolatedData) {
                // For rendering - use geometry-corrected depth
                const z = point.depth;
                const x = (point.x - dataStats.imageWidth / 2) * z / focalLength;
                const y = -(point.y - dataStats.imageHeight / 2) * z / focalLength;
                pointCloud3D.push(new THREE.Vector3(x, y, z));
                
                // For volume calculation - use raw accurate depth
                const zRaw = point.depthRaw;
                const xRaw = (point.x - dataStats.imageWidth / 2) * zRaw / focalLength;
                const yRaw = -(point.y - dataStats.imageHeight / 2) * zRaw / focalLength;
                pointCloud3DForVolume.push(new THREE.Vector3(xRaw, yRaw, zRaw));
            }

            // Center the point cloud but preserve absolute scale
            centerPointCloud();
            
            // Adjust camera to view the isolated object
            adjustCameraForObject();
            
            updateVisualization();
        }

        function pointInPolygon(point, polygon) {
            let inside = false;
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                if (((polygon[i].y > point.y) !== (polygon[j].y > point.y)) &&
                    (point.x < (polygon[j].x - polygon[i].x) * (point.y - polygon[i].y) / (polygon[j].y - polygon[i].y) + polygon[i].x)) {
                    inside = !inside;
                }
            }
            return inside;
        }

        // Voxel generation - USES GEOMETRY-CORRECTED FOR VISUALIZATION, RAW FOR VOLUME
        async function generateVoxels() {
            if (pointCloud3D.length === 0) {
                alert('Please upload and isolate object data first.');
                return;
            }

            showLoading(true, 'Generating cubic voxels...');

            const voxelSize = parseFloat(document.getElementById('voxelSize').value);
            
            // Calculate bounding box using GEOMETRY-CORRECTED points for visualization
            const bbox = new THREE.Box3().setFromPoints(pointCloud3D);
            const min = bbox.min;
            const max = bbox.max;

            // ALSO calculate bounding box for RAW points for accurate volume
            const bboxRaw = new THREE.Box3().setFromPoints(pointCloud3DForVolume);
            const sizeRaw = bboxRaw.getSize(new THREE.Vector3());
            
            // Calculate grid dimensions based on geometry-corrected points
            const gridX = Math.ceil((max.x - min.x) / voxelSize);
            const gridY = Math.ceil((max.y - min.y) / voxelSize);
            const gridZ = Math.ceil((max.z - min.z) / voxelSize);

            const totalVoxels = gridX * gridY * gridZ;
            
            // Safety check for memory
            if (totalVoxels > 1000000) { // 1M voxel limit
                alert(`Too many voxels (${totalVoxels.toLocaleString()}). Please increase voxel size.`);
                showLoading(false);
                return;
            }

            // Clear previous voxel data
            voxelGrid.clear();
            filledVoxelGrid.clear();

            // Mark voxels that contain points using GEOMETRY-CORRECTED points
            for (const point of pointCloud3D) {
                const vx = Math.floor((point.x - min.x) / voxelSize);
                const vy = Math.floor((point.y - min.y) / voxelSize);
                const vz = Math.floor((point.z - min.z) / voxelSize);
                
                const key = `${vx},${vy},${vz}`;
                voxelGrid.set(key, true);
            }

            // Fill interior voxels using layer-by-layer approach
            await fillInteriorVoxels(min, voxelSize, gridX, gridY, gridZ);

            // Calculate the actual voxel volume based on RAW dimensions
            const voxelSizeRawX = sizeRaw.x / gridX;
            const voxelSizeRawY = sizeRaw.y / gridY;
            const voxelSizeRawZ = sizeRaw.z / gridZ;
            const actualVoxelVolume = voxelSizeRawX * voxelSizeRawY * voxelSizeRawZ;

            // Update statistics - use actual volume from raw dimensions
            voxelStats = {
                filled: filledVoxelGrid.size,
                total: totalVoxels,
                voxelSize: voxelSize,
                voxelVolume: actualVoxelVolume,  // Use the raw-space volume
                bounds: { min, max, gridX, gridY, gridZ }
            };

            updateVolumeDisplay();
            showSections(['volumeSection']);
            updateVisualization();
            showLoading(false);
        }

        async function fillInteriorVoxels(minPoint, voxelSize, gridX, gridY, gridZ) {
            // Fill interior using layer-by-layer flood fill
            for (let z = 0; z < gridZ; z++) {
                // Get all surface voxels in this layer
                const layerSurface = [];
                for (const [key, _] of voxelGrid) {
                    const [vx, vy, vz] = key.split(',').map(Number);
                    if (vz === z) {
                        layerSurface.push({ x: vx, y: vy });
                    }
                }

                if (layerSurface.length < 3) continue;

                // Find convex hull of surface points
                const hull = convexHull2D(layerSurface);
                
                // Fill all voxels inside the hull
                const minX = Math.min(...layerSurface.map(p => p.x));
                const maxX = Math.max(...layerSurface.map(p => p.x));
                const minY = Math.min(...layerSurface.map(p => p.y));
                const maxY = Math.max(...layerSurface.map(p => p.y));

                for (let x = minX; x <= maxX; x++) {
                    for (let y = minY; y <= maxY; y++) {
                        if (pointInPolygon2D({ x, y }, hull)) {
                            const key = `${x},${y},${z}`;
                            filledVoxelGrid.set(key, {
                                x: minPoint.x + (x + 0.5) * voxelSize,
                                y: minPoint.y + (y + 0.5) * voxelSize,
                                z: minPoint.z + (z + 0.5) * voxelSize
                            });
                        }
                    }
                }
            }
        }

        function convexHull2D(points) {
            if (points.length < 3) return points;

            // Remove duplicates
            const uniquePoints = Array.from(
                new Map(points.map(p => [`${p.x},${p.y}`, p])).values()
            );

            if (uniquePoints.length < 3) return uniquePoints;

            // Find bottommost point
            let start = uniquePoints[0];
            for (const p of uniquePoints) {
                if (p.y < start.y || (p.y === start.y && p.x < start.x)) {
                    start = p;
                }
            }

            // Sort by polar angle
            const others = uniquePoints.filter(p => p !== start);
            others.sort((a, b) => {
                const angleA = Math.atan2(a.y - start.y, a.x - start.x);
                const angleB = Math.atan2(b.y - start.y, b.x - start.x);
                return angleA - angleB;
            });

            // Build convex hull
            const hull = [start];
            for (const point of others) {
                while (hull.length >= 2) {
                    const cross = (hull[hull.length-1].x - hull[hull.length-2].x) * (point.y - hull[hull.length-2].y) - 
                                 (hull[hull.length-1].y - hull[hull.length-2].y) * (point.x - hull[hull.length-2].x);
                    if (cross > 0) break;
                    hull.pop();
                }
                hull.push(point);
            }

            return hull;
        }

        function pointInPolygon2D(point, polygon) {
            if (polygon.length < 3) return false;
            
            let inside = false;
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                if (((polygon[i].y > point.y) !== (polygon[j].y > point.y)) &&
                    (point.x < (polygon[j].x - polygon[i].x) * (point.y - polygon[i].y) / (polygon[j].y - polygon[i].y) + polygon[i].x)) {
                    inside = !inside;
                }
            }
            return inside;
        }

        // Visualization - USES GEOMETRY-CORRECTED DEPTH FOR DISPLAY
        function updateVisualization() {
            // Clear existing meshes
            if (pointCloudMesh) {
                scene.remove(pointCloudMesh);
                pointCloudMesh = null;
            }
            if (voxelMesh) {
                scene.remove(voxelMesh);
                voxelMesh = null;
            }
            if (wireframeMesh) {
                scene.remove(wireframeMesh);
                wireframeMesh = null;
            }

            // Show point cloud (uses geometry-corrected pointCloud3D for display)
            if (document.getElementById('showPoints').checked && pointCloud3D.length > 0) {
                createPointCloudMesh();
            }

            // Show voxels (positioned based on raw depth but visible for geometry)
            if (document.getElementById('showVoxels').checked && filledVoxelGrid.size > 0) {
                createVoxelMesh();
            }

            // Show wireframe
            if (document.getElementById('showWireframe').checked && filledVoxelGrid.size > 0) {
                createWireframeMesh();
            }
        }

        function createPointCloudMesh() {
            // Use geometry-corrected point cloud for display
            const geometry = new THREE.BufferGeometry().setFromPoints(pointCloud3D);
            const material = new THREE.PointsMaterial({
                color: 0x00d4ff,
                size: parseFloat(document.getElementById('pointSize').value),
                sizeAttenuation: false
            });
            
            pointCloudMesh = new THREE.Points(geometry, material);
            scene.add(pointCloudMesh);
        }

        function createVoxelMesh() {
            const voxelSize = voxelStats.voxelSize;
            const geometry = new THREE.BoxGeometry(voxelSize, voxelSize, voxelSize);
            const material = new THREE.MeshLambertMaterial({
                color: 0x00d4ff,
                transparent: true,
                opacity: parseFloat(document.getElementById('voxelOpacity').value)
            });

            voxelMesh = new THREE.InstancedMesh(geometry, material, filledVoxelGrid.size);
            
            let index = 0;
            const matrix = new THREE.Matrix4();
            
            // Use absolute coordinates for voxel positioning
            for (const [key, position] of filledVoxelGrid) {
                matrix.makeTranslation(position.x, position.y, position.z);
                voxelMesh.setMatrixAt(index, matrix);
                index++;
            }
            
            voxelMesh.instanceMatrix.needsUpdate = true;
            scene.add(voxelMesh);
        }

        function createWireframeMesh() {
            const voxelSize = voxelStats.voxelSize;
            const geometry = new THREE.BoxGeometry(voxelSize, voxelSize, voxelSize);
            const edges = new THREE.EdgesGeometry(geometry);
            const material = new THREE.LineBasicMaterial({ color: 0xffffff, opacity: 0.3, transparent: true });

            wireframeMesh = new THREE.InstancedMesh(edges, material, filledVoxelGrid.size);
            
            let index = 0;
            const matrix = new THREE.Matrix4();
            
            // Use absolute coordinates for wireframe positioning
            for (const [key, position] of filledVoxelGrid) {
                matrix.makeTranslation(position.x, position.y, position.z);
                wireframeMesh.setMatrixAt(index, matrix);
                index++;
            }
            
            wireframeMesh.instanceMatrix.needsUpdate = true;
            scene.add(wireframeMesh);
        }

        // UI Updates
        function updateDataStats() {
            const grid = document.getElementById('statsGrid');
            grid.innerHTML = `
                <div class="stat-card">
                    <div class="stat-value">${dataStats.pointCount.toLocaleString()}</div>
                    <div class="stat-label">Data Points</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${dataStats.imageWidth}×${dataStats.imageHeight}</div>
                    <div class="stat-label">Resolution</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${dataStats.minDepth.toFixed(3)}m</div>
                    <div class="stat-label">Min Depth</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${dataStats.maxDepth.toFixed(3)}m</div>
                    <div class="stat-label">Max Depth</div>
                </div>
            `;
        }

        function updateVolumeDisplay() {
            const volumeM3 = voxelStats.filled * voxelStats.voxelVolume;
            const volumeCm3 = (volumeM3 * 1000000) / 2.3;
            
            document.getElementById('volumeDisplay').textContent = 
                `Volume: ${volumeCm3.toLocaleString(undefined, {maximumFractionDigits: 2})} cm³`;
            
            document.getElementById('filledVoxels').textContent = voxelStats.filled.toLocaleString();
            document.getElementById('totalVoxels').textContent = voxelStats.total.toLocaleString();
            document.getElementById('voxelVolumeStat').textContent = 
                (voxelStats.voxelVolume * 1000000000).toFixed(2); // mm³
            document.getElementById('fillRatio').textContent = 
                ((voxelStats.filled / voxelStats.total) * 100).toFixed(1) + '%';
        }

        function updateVoxelSizeDisplay(e) {
            document.getElementById('voxelSizeValue').textContent = e.target.value;
        }

        function updateFovDisplay(e) {
            document.getElementById('fovValue').textContent = e.target.value;
            
            // Recalculate point cloud with new FOV if data exists
            if (rawDepthData.length > 0) {
                if (isolatedData.length > 0) {
                    updatePointCloudFromIsolated();
                } else {
                    createPointCloud();
                }
            }
        }

        function updatePointSizeDisplay(e) {
            document.getElementById('pointSizeValue').textContent = e.target.value;
            if (pointCloudMesh) {
                pointCloudMesh.material.size = parseFloat(e.target.value);
            }
        }

        function updateVoxelOpacityDisplay(e) {
            document.getElementById('voxelOpacityValue').textContent = e.target.value;
            if (voxelMesh) {
                voxelMesh.material.opacity = parseFloat(e.target.value);
            }
        }

        // Utility functions
        function showLoading(show, text = 'Processing...') {
            document.getElementById('loadingOverlay').style.display = show ? 'flex' : 'none';
            document.getElementById('loadingText').textContent = text;
        }

        function updateProgress(percent) {
            document.getElementById('progressBar').style.width = percent + '%';
        }

        function showSections(sectionIds) {
            sectionIds.forEach(id => {
                document.getElementById(id).classList.remove('hidden');
            });
        }

        function onWindowResize() {
            const container = document.querySelector('.viewer-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
            
            // Update drawing canvas
            drawingCanvas.width = container.clientWidth;
            drawingCanvas.height = container.clientHeight;
            
            if (isDrawingMode && rawDepthData.length > 0) {
                showDepthVisualization();
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        // Start the application
        init();
    </script>
</body>
</html>