<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Depth Volume Analyzer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            overflow-x: hidden;
        }
        
        .container {
            display: grid;
            grid-template-columns: 350px 1fr;
            height: 100vh;
        }
        
        .sidebar {
            background: rgba(0, 0, 0, 0.3);
            padding: 20px;
            overflow-y: auto;
            backdrop-filter: blur(10px);
        }
        
        .main-view {
            position: relative;
            background: #000;
        }
        
        h1 {
            font-size: 24px;
            margin: 0 0 20px 0;
            background: linear-gradient(45deg, #4facfe, #00f2fe);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .section {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .section h3 {
            margin: 0 0 15px 0;
            font-size: 16px;
            color: #4facfe;
        }
        
        .file-input {
            width: 100%;
            padding: 10px;
            border: 2px dashed #4facfe;
            border-radius: 8px;
            background: rgba(79, 172, 254, 0.1);
            color: white;
            text-align: center;
            cursor: pointer;
            margin-bottom: 10px;
        }
        
        .file-input:hover {
            background: rgba(79, 172, 254, 0.2);
        }
        
        input[type="file"] {
            display: none;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
            color: #ccc;
        }
        
        input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }
        
        .value-display {
            font-family: monospace;
            background: rgba(0, 0, 0, 0.3);
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 12px;
        }
        
        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 10px;
        }
        
        input[type="checkbox"] {
            width: 16px;
            height: 16px;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .stat-item {
            background: rgba(0, 0, 0, 0.3);
            padding: 8px;
            border-radius: 6px;
            text-align: center;
        }
        
        .stat-value {
            font-size: 18px;
            font-weight: bold;
            color: #4facfe;
        }
        
        .stat-label {
            font-size: 11px;
            color: #aaa;
        }
        
        .method-tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
        }
        
        .tab {
            flex: 1;
            padding: 8px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            text-align: center;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
        }
        
        .tab.active {
            background: #4facfe;
            color: black;
        }
        
        .volume-result {
            background: linear-gradient(45deg, #4facfe, #00f2fe);
            color: black;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            font-weight: bold;
            margin-bottom: 15px;
            font-size: 20px;
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            z-index: 1000;
        }
        
        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(79, 172, 254, 0.3);
            border-left: 4px solid #4facfe;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .progress-bar {
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            overflow: hidden;
            margin-bottom: 10px;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4facfe, #00f2fe);
            width: 0%;
            transition: width 0.3s ease;
        }
        
        #renderCanvas {
            display: block;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="sidebar">
            <h1>üî¨ 3D Volume Analyzer</h1>
            
            <div class="section">
                <h3>üìÅ Data Input</h3>
                <div class="file-input" onclick="document.getElementById('csvFile').click()">
                    <div>üìä Upload Depth CSV</div>
                    <div style="font-size: 12px; opacity: 0.7;">Click to select file</div>
                </div>
                <input type="file" id="csvFile" accept=".csv" />
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
            </div>
            
            <div class="section" id="statsSection" style="display: none;">
                <h3>üìä Raw Data Statistics</h3>
                <div class="stats-grid" id="statsGrid"></div>
            </div>

            <div class="section" id="isolationSection" style="display: none;">
                <h3>‚úÇÔ∏è Object Isolation</h3>
                <div class="control-group">
                    <label>Depth Range Filter (meters): <span class="value-display" id="depthFilterValue">0-1</span></label>
                    <input type="range" id="minDepthFilter" min="0" max="5" step="0.05" value="0">
                    <input type="range" id="maxDepthFilter" min="0" max="5" step="0.05" value="1">
                </div>
                 <div class="control-group">
                    <label>Points After Filtering: <span class="value-display" id="filteredPointsCount">0</span></label>
                </div>
            </div>

            <div class="section" id="advancedSection" style="display: none;">
                <h3>‚öôÔ∏è Calibration</h3>
                <div class="control-group">
                    <label>Camera FOV (Horiz.): <span class="value-display" id="fovValue">62</span>¬∞</label>
                    <input type="range" id="cameraFov" min="40" max="90" step="1" value="62">
                </div>
            </div>
            
            <div class="section" id="volumeSection" style="display: none;">
                <h3>üìê Volume Calculation</h3>
                <div class="method-tabs">
                    <div class="tab active" data-method="voxel">Voxel</div>
                    <div class="tab" data-method="mesh">Mesh</div>
                    <div class="tab" data-method="convex">Convex Hull</div>
                </div>
                <div class="volume-result" id="volumeResult">
                    Volume: 0 cm¬≥
                </div>
                <div class="control-group" id="voxelControl">
                    <label>Voxel Size: <span class="value-display" id="voxelSizeValue">0.005</span>m</label>
                    <input type="range" id="voxelSize" min="0.001" max="0.05" step="0.001" value="0.005">
                </div>
            </div>

            <div class="section" id="vizSection" style="display: none;">
                <h3>üëÅÔ∏è Visualization</h3>
                <div class="checkbox-group">
                    <input type="checkbox" id="showPointCloud" checked>
                    <label for="showPointCloud">Point Cloud</label>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="showMesh" checked>
                    <label for="showMesh">Mesh Surface</label>
                </div>
                <div class="control-group">
                    <label>Point Size: <span class="value-display" id="pointSizeValue">2</span></label>
                    <input type="range" id="pointSize" min="1" max="10" step="1" value="2">
                </div>
                <div class="control-group">
                    <label>Mesh Resolution: <span class="value-display" id="meshResValue">1</span></label>
                    <input type="range" id="meshResolution" min="1" max="5" step="1" value="1">
                </div>
            </div>
            
            <div class="section" id="algorithmInfo">
                <h3>üßÆ Algorithm Details</h3>
                <div id="algorithmDescription" style="font-size: 12px; line-height: 1.4;">
                    Upload data to see calculation methods. The Voxel method is generally the most reliable for non-watertight objects.
                </div>
            </div>
        </div>
        
        <div class="main-view">
            <canvas id="renderCanvas"></canvas>
            <div class="loading" id="loading" style="display: none;">
                <div class="spinner"></div>
                <div id="loadingText">Processing...</div>
            </div>
        </div>
    </div>

    <script>
        // --- Global State ---
        let scene, camera, renderer, controls;
        let pointCloud, meshSurface;
        
        let rawDepthData = [], filteredDepthData = [], metricPointCloud = [], vizPointCloud = [];
        
        let stats = {};
        let currentMethod = 'voxel';

        // --- Initialization ---
        function initThreeJS() {
            const canvas = document.getElementById('renderCanvas');
            const container = canvas.parentElement;
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0a);
            
            camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.01, 1000);
            camera.position.set(0.5, 0.5, 0.5);
            camera.lookAt(0, 0, 0);
            
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);
            
            setupBasicControls();
            scene.add(new THREE.AxesHelper(0.5));
            animate();
            
            window.addEventListener('resize', onWindowResize);
        }

        // --- Main Data Processing Pipeline ---
        async function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            showLoading(true, 'Parsing CSV...');
            updateProgress(0);

            try {
                const text = await file.text();
                updateProgress(20);
                
                await parseCSVData(text);
                updateProgress(40);
                
                showUI();
                await processAndCalculate();

            } catch (error) {
                console.error('Error processing file:', error);
                alert('Error processing file. Check console for details.');
            } finally {
                showLoading(false);
            }
        }

        async function parseCSVData(text) {
            return new Promise(resolve => {
                const lines = text.trim().split('\n');
                rawDepthData = [];
                
                let minDepth = Infinity, maxDepth = -Infinity;
                let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
                
                for (let i = 1; i < lines.length; i++) {
                    const cols = lines[i].split(',');
                    if (cols.length >= 3) {
                        const x = parseInt(cols[0]);
                        const y = parseInt(cols[1]);
                        const depth = parseFloat(cols[2]);
                        
                        if (!isNaN(x) && !isNaN(y) && !isNaN(depth) && depth > 0 && isFinite(depth)) {
                            rawDepthData.push({ x, y, depth });
                            minDepth = Math.min(minDepth, depth);
                            maxDepth = Math.max(maxDepth, depth);
                            minX = Math.min(minX, x);
                            maxX = Math.max(maxX, x);
                            minY = Math.min(minY, y);
                            maxY = Math.max(maxY, y);
                        }
                    }
                }
                
                stats = {
                    pointCount: rawDepthData.length,
                    minDepth: minDepth,
                    maxDepth: maxDepth,
                    // *** FIX: Calculate the full image dimensions from the max coordinates,
                    // not the bounding box of the valid points. This is crucial.
                    imageWidth: maxX + 1,
                    imageHeight: maxY + 1,
                };
                
                updateStatsDisplay();
                resolve();
            });
        }

        async function processAndCalculate() {
            if (rawDepthData.length === 0) return;

            showLoading(true, 'Isolating object...');
            await new Promise(r => setTimeout(r, 10));

            filterDepthData();
            document.getElementById('filteredPointsCount').textContent = filteredDepthData.length.toLocaleString();

            if (filteredDepthData.length === 0) {
                showLoading(false);
                alert("No data points remain after filtering. Adjust the depth range.");
                return;
            }

            showLoading(true, 'Creating metric model...');
            await new Promise(r => setTimeout(r, 10));
            createMetricPointCloud();

            showLoading(true, 'Calculating volume...');
            await new Promise(r => setTimeout(r, 10));
            calculateVolume();

            showLoading(true, 'Generating visualization...');
            await new Promise(r => setTimeout(r, 10));
            createVisualizationData();
            updateVisualization();

            showLoading(false);
        }

        function filterDepthData() {
            const minDepth = parseFloat(document.getElementById('minDepthFilter').value);
            const maxDepth = parseFloat(document.getElementById('maxDepthFilter').value);
            
            filteredDepthData = rawDepthData.filter(p => p.depth >= minDepth && p.depth <= maxDepth);
        }

        function createMetricPointCloud() {
            metricPointCloud = [];
            if (filteredDepthData.length === 0) return;

            // *** FIX: Use the correct full imageWidth and imageHeight from stats.
            const imageWidth = stats.imageWidth;
            const imageHeight = stats.imageHeight;

            const fov = parseFloat(document.getElementById('cameraFov').value) * (Math.PI / 180);
            const focalLength = (imageWidth / 2) / Math.tan(fov / 2);

            for (const p of filteredDepthData) {
                const z = p.depth;
                // The projection now uses the correct principal point (imageWidth/2)
                // relative to the absolute pixel coordinates (p.x).
                const x = (p.x - imageWidth / 2) * z / focalLength;
                const y = -(p.y - imageHeight / 2) * z / focalLength;

                metricPointCloud.push(new THREE.Vector3(x, y, z));
            }
        }

        function calculateVolume() {
            let volumeM3 = 0;

            if (metricPointCloud.length < 4) {
                updateVolumeDisplay(0);
                return;
            }

            switch (currentMethod) {
                case 'voxel':
                    volumeM3 = calculateVoxelVolume();
                    break;
                case 'mesh':
                    volumeM3 = calculateMeshVolume();
                    break;
                case 'convex':
                    volumeM3 = calculateConvexHullVolume();
                    break;
            }
            
            updateVolumeDisplay(volumeM3);
            updateAlgorithmInfo();
        }

        function calculateVoxelVolume() {
            const voxelSize = parseFloat(document.getElementById('voxelSize').value);
            if (voxelSize <= 0) return 0;

            const voxelVolume = Math.pow(voxelSize, 3);
            const voxels = new Set();

            for (const point of metricPointCloud) {
                const vx = Math.floor(point.x / voxelSize);
                const vy = Math.floor(point.y / voxelSize);
                const vz = Math.floor(point.z / voxelSize);
                voxels.add(`${vx},${vy},${vz}`);
            }
            
            return voxels.size * voxelVolume;
        }
        
        function calculateMeshVolume() {
            const { vertices, faces } = generateMesh(metricPointCloud);
            if (faces.length === 0) {
                console.warn('No mesh faces available for volume calculation.');
                return 0;
            }
            
            let volume = 0;
            for (let i = 0; i < faces.length; i += 3) {
                const v1 = vertices[faces[i]];
                const v2 = vertices[faces[i+1]];
                const v3 = vertices[faces[i+2]];
                
                volume += v1.dot(v2.clone().cross(v3));
            }
            
            return Math.abs(volume / 6.0);
        }

        function calculateConvexHullVolume() {
            const box = new THREE.Box3().setFromPoints(metricPointCloud);
            const size = new THREE.Vector3();
            box.getSize(size);
            return size.x * size.y * size.z * 0.5; 
        }

        function createVisualizationData() {
            vizPointCloud = [];
            if (metricPointCloud.length === 0) return;

            const box = new THREE.Box3().setFromPoints(metricPointCloud);
            const center = new THREE.Vector3();
            box.getCenter(center);
            const size = new THREE.Vector3();
            box.getSize(size);
            const maxDim = Math.max(size.x, size.y, size.z);
            if (maxDim === 0) return;

            for (const p of metricPointCloud) {
                vizPointCloud.push(
                    p.clone().sub(center).divideScalar(maxDim)
                );
            }
        }
        
        function updateVisualization() {
            if (scene) {
                if (pointCloud) scene.remove(pointCloud);
                if (meshSurface) scene.remove(meshSurface);
            }

            if (vizPointCloud.length === 0) return;

            if (document.getElementById('showPointCloud').checked) {
                createPointCloudVisualization();
            }
            
            if (document.getElementById('showMesh').checked) {
                createMeshVisualization();
            }
        }

        function createPointCloudVisualization() {
            const geometry = new THREE.BufferGeometry().setFromPoints(vizPointCloud);
            const material = new THREE.PointsMaterial({
                size: parseFloat(document.getElementById('pointSize').value),
                sizeAttenuation: false,
                color: 0x4facfe
            });
            pointCloud = new THREE.Points(geometry, material);
            scene.add(pointCloud);
        }
        
        function createMeshVisualization() {
            const { vertices, faces } = generateMesh(vizPointCloud);
            if (faces.length === 0) return;

            const geometry = new THREE.BufferGeometry();
            geometry.setFromPoints(vertices);
            geometry.setIndex(faces);
            geometry.computeVertexNormals();

            const material = new THREE.MeshLambertMaterial({
                color: 0x00f2fe,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.8
            });

            meshSurface = new THREE.Mesh(geometry, material);
            scene.add(meshSurface);
        }

        function generateMesh(points) {
            const resolution = parseInt(document.getElementById('meshResolution').value);
            let vertices = [], faces = [];
            if (points.length === 0) return { vertices, faces };

            const grid = {};
            const box = new THREE.Box3().setFromPoints(points);
            const size = new THREE.Vector3();
            box.getSize(size);

            if (size.x === 0 || size.y === 0) return { vertices, faces };

            // *** FIX: Base grid density on full sensor resolution for consistency.
            const gridDivisionsX = stats.imageWidth / resolution;
            const gridDivisionsY = stats.imageHeight / resolution;

            for(let i = 0; i < points.length; i++) {
                const p = points[i];
                // Map a point's position within its bounding box to the grid
                const gx = Math.floor(((p.x - box.min.x) / size.x) * gridDivisionsX);
                const gy = Math.floor(((p.y - box.min.y) / size.y) * gridDivisionsY);
                const key = `${gx},${gy}`;
                
                if (!grid[key] || grid[key].point.z > p.z) {
                    grid[key] = { point: p, index: i };
                }
            }

            const gridPoints = Object.values(grid);
            const vertexMap = new Map();

            gridPoints.forEach((gp, i) => {
                vertices.push(gp.point);
                const gx = Math.floor(((gp.point.x - box.min.x) / size.x) * gridDivisionsX);
                const gy = Math.floor(((gp.point.y - box.min.y) / size.y) * gridDivisionsY);
                vertexMap.set(`${gx},${gy}`, i);
            });

            for (const key of vertexMap.keys()) {
                const [gx, gy] = key.split(',').map(Number);
                const current = vertexMap.get(`${gx},${gy}`);
                const right = vertexMap.get(`${gx + 1},${gy}`);
                const down = vertexMap.get(`${gx},${gy + 1}`);
                const diag = vertexMap.get(`${gx + 1},${gy + 1}`);

                if (current !== undefined && right !== undefined && down !== undefined) {
                    faces.push(current, down, right);
                }
                if (right !== undefined && down !== undefined && diag !== undefined) {
                    faces.push(right, down, diag);
                }
            }

            return { vertices, faces };
        }

        function showLoading(show, text = 'Processing...') {
            document.getElementById('loading').style.display = show ? 'block' : 'none';
            document.getElementById('loadingText').textContent = text;
        }

        function updateProgress(percent) {
            document.getElementById('progressFill').style.width = percent + '%';
        }

        function showUI() {
            document.getElementById('statsSection').style.display = 'block';
            document.getElementById('vizSection').style.display = 'block';
            document.getElementById('volumeSection').style.display = 'block';
            document.getElementById('isolationSection').style.display = 'block';
            document.getElementById('advancedSection').style.display = 'block';
        }

        function updateStatsDisplay() {
            const grid = document.getElementById('statsGrid');
            grid.innerHTML = `
                <div class="stat-item"><div class="stat-value">${stats.pointCount.toLocaleString()}</div><div class="stat-label">Raw Points</div></div>
                <div class="stat-item"><div class="stat-value">${stats.imageWidth}√ó${stats.imageHeight}</div><div class="stat-label">Sensor Resolution</div></div>
                <div class="stat-item"><div class="stat-value">${stats.minDepth.toFixed(3)}m</div><div class="stat-label">Min Depth</div></div>
                <div class="stat-item"><div class="stat-value">${stats.maxDepth.toFixed(3)}m</div><div class="stat-label">Max Depth</div></div>
            `;
            document.getElementById('minDepthFilter').max = stats.maxDepth.toFixed(2);
            document.getElementById('maxDepthFilter').max = stats.maxDepth.toFixed(2);
        }

        function updateVolumeDisplay(volumeM3) {
            const volumeCm3 = volumeM3 * 1_000_000;
            const result = document.getElementById('volumeResult');
            result.innerHTML = `Volume: ${volumeCm3.toLocaleString(undefined, {maximumFractionDigits: 2})} cm¬≥`;
        }

        function updateAlgorithmInfo() {
            const info = document.getElementById('algorithmDescription');
            const descriptions = {
                convex: 'Convex Hull: Volume of the smallest convex shape containing the object. Fast but inaccurate for concave shapes. Approximated from bounding box.',
                voxel: 'Voxel Method: Fills the object with tiny cubes (voxels) and sums their volume. Reliable and accurate, especially for complex or non-watertight shapes.',
                mesh: 'Mesh Volume: Calculates volume from a triangular surface mesh. Can be very accurate if the mesh is "watertight", but may fail on sparse data.'
            };
            info.textContent = descriptions[currentMethod];
        }

        function setupBasicControls() {
            let isMouseDown = false;
            let prevMouseX = 0, prevMouseY = 0;
            const canvas = renderer.domElement;

            canvas.addEventListener('mousedown', e => { isMouseDown = true; prevMouseX = e.clientX; prevMouseY = e.clientY; });
            canvas.addEventListener('mouseup', () => isMouseDown = false);
            canvas.addEventListener('mouseout', () => isMouseDown = false);
            
            canvas.addEventListener('mousemove', e => {
                if (!isMouseDown) return;
                const deltaX = e.clientX - prevMouseX;
                const deltaY = e.clientY - prevMouseY;
                scene.rotation.y += deltaX * 0.005;
                scene.rotation.x += deltaY * 0.005;
                prevMouseX = e.clientX;
                prevMouseY = e.clientY;
            });

            canvas.addEventListener('wheel', e => {
                camera.position.z *= (e.deltaY > 0 ? 1.1 : 0.9);
            }, { passive: true });
        }

        function onWindowResize() {
            const container = document.querySelector('.main-view');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        // --- Event Listeners ---
        document.getElementById('csvFile').addEventListener('change', handleFileUpload);

        const recalcControls = ['minDepthFilter', 'maxDepthFilter', 'meshResolution', 'voxelSize', 'cameraFov'];
        recalcControls.forEach(id => {
            document.getElementById(id).addEventListener('change', () => {
                 if(rawDepthData.length > 0) processAndCalculate();
            });
        });

        document.getElementById('minDepthFilter').addEventListener('input', e => {
            const min = parseFloat(e.target.value);
            const max = parseFloat(document.getElementById('maxDepthFilter').value);
            document.getElementById('depthFilterValue').textContent = `${min.toFixed(2)}-${max.toFixed(2)}`;
        });
        document.getElementById('maxDepthFilter').addEventListener('input', e => {
            const min = parseFloat(document.getElementById('minDepthFilter').value);
            const max = parseFloat(e.target.value);
            document.getElementById('depthFilterValue').textContent = `${min.toFixed(2)}-${max.toFixed(2)}`;
        });
        document.getElementById('pointSize').addEventListener('input', e => {
            document.getElementById('pointSizeValue').textContent = e.target.value;
            if (pointCloud) {
                pointCloud.material.size = parseFloat(e.target.value);
            }
        });
        document.getElementById('meshResolution').addEventListener('input', e => {
            document.getElementById('meshResValue').textContent = e.target.value;
        });
        document.getElementById('voxelSize').addEventListener('input', e => {
            document.getElementById('voxelSizeValue').textContent = e.target.value;
        });
        document.getElementById('cameraFov').addEventListener('input', e => {
            document.getElementById('fovValue').textContent = e.target.value;
        });
        
        document.getElementById('showPointCloud').addEventListener('change', updateVisualization);
        document.getElementById('showMesh').addEventListener('change', updateVisualization);

        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', (e) => {
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                const newMethod = e.target.dataset.method;
                e.target.classList.add('active');
                currentMethod = newMethod;
                
                document.getElementById('voxelControl').style.display = newMethod === 'voxel' ? 'block' : 'none';

                if (rawDepthData.length > 0) calculateVolume();
            });
        });
        
        initThreeJS();
    </script>
</body>
</html>
