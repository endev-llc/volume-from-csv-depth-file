<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Depth Volume Analyzer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            overflow-x: hidden;
        }
        
        .container {
            display: grid;
            grid-template-columns: 350px 1fr;
            height: 100vh;
        }
        
        .sidebar {
            background: rgba(0, 0, 0, 0.3);
            padding: 20px;
            overflow-y: auto;
            backdrop-filter: blur(10px);
        }
        
        .main-view {
            position: relative;
            background: #000;
        }
        
        h1 {
            font-size: 24px;
            margin: 0 0 20px 0;
            background: linear-gradient(45deg, #4facfe, #00f2fe);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .section {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .section h3 {
            margin: 0 0 15px 0;
            font-size: 16px;
            color: #4facfe;
        }
        
        .file-input {
            width: 100%;
            padding: 10px;
            border: 2px dashed #4facfe;
            border-radius: 8px;
            background: rgba(79, 172, 254, 0.1);
            color: white;
            text-align: center;
            cursor: pointer;
            margin-bottom: 10px;
        }
        
        .file-input:hover {
            background: rgba(79, 172, 254, 0.2);
        }
        
        input[type="file"] {
            display: none;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
            color: #ccc;
        }
        
        input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }
        
        .value-display {
            font-family: monospace;
            background: rgba(0, 0, 0, 0.3);
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 12px;
        }
        
        button {
            width: 100%;
            padding: 10px;
            border: none;
            border-radius: 8px;
            background: linear-gradient(45deg, #4facfe, #00f2fe);
            color: black;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s ease;
        }

        button:hover {
            transform: scale(1.02);
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 10px;
        }
        
        input[type="checkbox"] {
            width: 16px;
            height: 16px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .stat-item {
            background: rgba(0, 0, 0, 0.3);
            padding: 8px;
            border-radius: 6px;
            text-align: center;
        }
        
        .stat-value {
            font-size: 18px;
            font-weight: bold;
            color: #4facfe;
        }
        
        .stat-label {
            font-size: 11px;
            color: #aaa;
        }
        
        .method-tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
        }
        
        .tab {
            flex: 1;
            padding: 8px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            text-align: center;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
        }
        
        .tab.active {
            background: #4facfe;
            color: black;
        }
        
        .volume-result {
            background: linear-gradient(45deg, #4facfe, #00f2fe);
            color: black;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            font-weight: bold;
            margin-bottom: 15px;
            font-size: 20px;
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            z-index: 1000;
        }
        
        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(79, 172, 254, 0.3);
            border-left: 4px solid #4facfe;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .progress-bar {
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            overflow: hidden;
            margin-bottom: 10px;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4facfe, #00f2fe);
            width: 0%;
            transition: width 0.3s ease;
        }
        
        #renderCanvas {
            display: block;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="sidebar">
            <h1>üî¨ 3D Volume Analyzer</h1>
            
            <div class="section">
                <h3>üìÅ Data Input</h3>
                <div class="file-input" onclick="document.getElementById('csvFile').click()">
                    <div>üìä Upload Depth CSV</div>
                    <div style="font-size: 12px; opacity: 0.7;">Click to select file</div>
                </div>
                <input type="file" id="csvFile" accept=".csv" />
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
            </div>
            
            <div class="section" id="statsSection" style="display: none;">
                <h3>üìä Raw Data Statistics</h3>
                <div class="stats-grid" id="statsGrid"></div>
            </div>

            <div class="section" id="isolationSection" style="display: none;">
                <h3>‚úÇÔ∏è Object Isolation</h3>
                <div class="control-group">
                    <label>Depth Range Filter (meters): <span class="value-display" id="depthFilterValue">0-1</span></label>
                    <input type="range" id="minDepthFilter" min="0" max="5" step="0.05" value="0">
                    <input type="range" id="maxDepthFilter" min="0" max="5" step="0.05" value="1">
                </div>
                 <div class="control-group">
                    <label>Points After Filtering: <span class="value-display" id="filteredPointsCount">0</span></label>
                </div>
            </div>

            <div class="section" id="noiseReductionSection" style="display: none;">
                <h3>üßπ Noise Reduction</h3>
                <div class="control-group">
                    <button id="removeNoiseBtn">Remove Stray Points</button>
                </div>
                <div class="control-group">
                    <label>Points After Cleanup: <span class="value-display" id="cleanedPointsCount">0</span></label>
                </div>
            </div>

            <div class="section" id="advancedSection" style="display: none;">
                <h3>‚öôÔ∏è Calibration</h3>
                <div class="control-group">
                    <label>Camera FOV (Horiz.): <span class="value-display" id="fovValue">62</span>¬∞</label>
                    <input type="range" id="cameraFov" min="40" max="90" step="1" value="62">
                </div>
            </div>
            
            <div class="section" id="volumeSection" style="display: none;">
                <h3>üìê Volume Calculation</h3>
                <div class="method-tabs">
                    <div class="tab active" data-method="voxel">Voxel</div>
                </div>
                <div class="volume-result" id="volumeResult">
                    Volume: 0 cm¬≥
                </div>
                <div class="control-group" id="voxelControl">
                    <label>Voxel Size: <span class="value-display" id="voxelSizeValue">0.005</span>m</label>
                    <input type="range" id="voxelSize" min="0.001" max="0.05" step="0.001" value="0.005">
                </div>
            </div>

            <div class="section" id="vizSection" style="display: none;">
                <h3>üëÅÔ∏è Visualization</h3>
                <div class="checkbox-group">
                    <input type="checkbox" id="showPointCloud" checked>
                    <label for="showPointCloud">Point Cloud</label>
                </div>
                 <div class="checkbox-group">
                    <input type="checkbox" id="showMesh" checked>
                    <label for="showMesh">Mesh Surface</label>
                </div>
                <div class="control-group">
                    <label>Point Size: <span class="value-display" id="pointSizeValue">2</span></label>
                    <input type="range" id="pointSize" min="1" max="10" step="1" value="2">
                </div>
            </div>
        </div>
        
        <div class="main-view">
            <canvas id="renderCanvas"></canvas>
            <div class="loading" id="loading" style="display: none;">
                <div class="spinner"></div>
                <div id="loadingText">Processing...</div>
            </div>
        </div>
    </div>

    <script>
        // --- Global State ---
        let scene, camera, renderer, controls;
        let pointCloud, meshSurface;
        
        let rawDepthData = [];
        let depthFilteredData = [];
        let finalPoints = [];
        let metricPointCloud = [];
        let vizPointCloud = [];
        
        let stats = {};
        let currentMethod = 'voxel';

        // --- Initialization ---
        function initThreeJS() {
            const canvas = document.getElementById('renderCanvas');
            const container = canvas.parentElement;
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0a);
            
            camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.01, 1000);
            camera.position.set(0.5, 0.5, 0.5);
            camera.lookAt(0, 0, 0);
            
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);
            
            setupBasicControls();
            scene.add(new THREE.AxesHelper(0.5));
            animate();
            
            window.addEventListener('resize', onWindowResize);
        }

        // --- Main Data Processing Pipeline ---
        async function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            showLoading(true, 'Parsing CSV...');
            updateProgress(0);

            try {
                const text = await file.text();
                updateProgress(20);
                
                await parseCSVData(text);
                updateProgress(40);
                
                showUI();
                await runFullPipeline();

            } catch (error) {
                console.error('Error processing file:', error);
                alert('Error processing file. Check console for details.');
            } finally {
                showLoading(false);
            }
        }
        
        async function runFullPipeline() {
            showLoading(true, 'Filtering depth...');
            await new Promise(r => setTimeout(r, 10));
            filterByDepth();
            document.getElementById('filteredPointsCount').textContent = depthFilteredData.length.toLocaleString();
            
            finalPoints = [...depthFilteredData];
            document.getElementById('cleanedPointsCount').textContent = 'N/A';

            await calculateAndVisualize();
        }

        async function calculateAndVisualize() {
            if (finalPoints.length === 0) {
                showLoading(false);
                updateVisualization(); // Clear the screen
                alert("No data points remain to process.");
                return;
            }
            
            showLoading(true, 'Creating metric model...');
            await new Promise(r => setTimeout(r, 10));
            createMetricPointCloud();

            showLoading(true, 'Calculating volume...');
            await new Promise(r => setTimeout(r, 10));
            calculateVolume();

            showLoading(true, 'Generating visualization...');
            await new Promise(r => setTimeout(r, 10));
            createVisualizationData();
            updateVisualization();

            showLoading(false);
        }

        async function parseCSVData(text) {
            return new Promise(resolve => {
                const lines = text.trim().split('\n');
                rawDepthData = [];
                let minDepth = Infinity, maxDepth = -Infinity;
                let maxX = -Infinity, maxY = -Infinity;
                
                for (let i = 1; i < lines.length; i++) {
                    const cols = lines[i].split(',');
                    if (cols.length >= 3) {
                        const x = parseInt(cols[0]);
                        const y = parseInt(cols[1]);
                        const depth = parseFloat(cols[2]);
                        
                        if (!isNaN(x) && !isNaN(y) && !isNaN(depth) && depth > 0 && isFinite(depth)) {
                            rawDepthData.push({ x, y, depth, index: rawDepthData.length });
                            minDepth = Math.min(minDepth, depth);
                            maxDepth = Math.max(maxDepth, depth);
                            maxX = Math.max(maxX, x);
                            maxY = Math.max(maxY, y);
                        }
                    }
                }
                
                stats = {
                    pointCount: rawDepthData.length,
                    minDepth: minDepth,
                    maxDepth: maxDepth,
                    imageWidth: maxX + 1,
                    imageHeight: maxY + 1,
                };
                
                updateStatsDisplay();
                resolve();
            });
        }

        function filterByDepth() {
            const minDepth = parseFloat(document.getElementById('minDepthFilter').value);
            const maxDepth = parseFloat(document.getElementById('maxDepthFilter').value);
            depthFilteredData = rawDepthData.filter(p => p.depth >= minDepth && p.depth <= maxDepth);
        }

        // --- OPTIMIZED: Noise Reduction Logic ---
        async function handleRemoveNoise() {
            if (depthFilteredData.length === 0) {
                alert("No points to process. Adjust depth filter first.");
                return;
            }
            showLoading(true, 'Finding largest cluster...');
            await new Promise(r => setTimeout(r, 10));

            const neighborRadius = 5; // in pixels
            const cellSize = neighborRadius * 2;
            const grid = new Map();

            // 1. Place points into a spatial grid
            for (const point of depthFilteredData) {
                const gridX = Math.floor(point.x / cellSize);
                const gridY = Math.floor(point.y / cellSize);
                const key = `${gridX},${gridY}`;
                if (!grid.has(key)) {
                    grid.set(key, []);
                }
                grid.get(key).push(point);
            }

            const clusters = [];
            const visited = new Set();

            // 2. Iterate through points to find clusters
            for (const point of depthFilteredData) {
                if (visited.has(point.index)) continue;

                const newCluster = [];
                const queue = [point];
                visited.add(point.index);

                while (queue.length > 0) {
                    const currentPoint = queue.shift();
                    newCluster.push(currentPoint);

                    const gridX = Math.floor(currentPoint.x / cellSize);
                    const gridY = Math.floor(currentPoint.y / cellSize);

                    // 3. Search only neighboring cells (9 total)
                    for (let dx = -1; dx <= 1; dx++) {
                        for (let dy = -1; dy <= 1; dy++) {
                            const key = `${gridX + dx},${gridY + dy}`;
                            if (grid.has(key)) {
                                for (const neighbor of grid.get(key)) {
                                    if (visited.has(neighbor.index)) continue;

                                    const distSq = Math.pow(currentPoint.x - neighbor.x, 2) + Math.pow(currentPoint.y - neighbor.y, 2);
                                    if (distSq < Math.pow(neighborRadius, 2)) {
                                        visited.add(neighbor.index);
                                        queue.push(neighbor);
                                    }
                                }
                            }
                        }
                    }
                }
                clusters.push(newCluster);
            }

            if (clusters.length > 0) {
                clusters.sort((a, b) => b.length - a.length);
                finalPoints = clusters[0];
            } else {
                finalPoints = [];
            }
            
            document.getElementById('cleanedPointsCount').textContent = finalPoints.length.toLocaleString();
            await calculateAndVisualize();
        }


        function createMetricPointCloud() {
            metricPointCloud = [];
            if (finalPoints.length === 0) return;
            const imageWidth = stats.imageWidth;
            const imageHeight = stats.imageHeight;
            const fov = parseFloat(document.getElementById('cameraFov').value) * (Math.PI / 180);
            const focalLength = (imageWidth / 2) / Math.tan(fov / 2);
            for (const p of finalPoints) {
                const z = p.depth;
                const x = (p.x - imageWidth / 2) * z / focalLength;
                const y = -(p.y - imageHeight / 2) * z / focalLength;
                metricPointCloud.push(new THREE.Vector3(x, y, z));
            }
        }

        function calculateVolume() {
            let volumeM3 = 0;
            if (metricPointCloud.length < 4) {
                updateVolumeDisplay(0);
                return;
            }
            if (currentMethod === 'voxel') {
                volumeM3 = calculateVoxelVolume();
            }
            updateVolumeDisplay(volumeM3);
        }

        function calculateVoxelVolume() {
            const voxelSize = parseFloat(document.getElementById('voxelSize').value);
            if (voxelSize <= 0) return 0;
            const voxelVolume = Math.pow(voxelSize, 3);
            const voxels = new Set();
            for (const point of metricPointCloud) {
                const vx = Math.floor(point.x / voxelSize);
                const vy = Math.floor(point.y / voxelSize);
                const vz = Math.floor(point.z / voxelSize);
                voxels.add(`${vx},${vy},${vz}`);
            }
            return voxels.size * voxelVolume;
        }

        function createVisualizationData() {
            vizPointCloud = [];
            if (metricPointCloud.length === 0) return;
            const box = new THREE.Box3().setFromPoints(metricPointCloud);
            const center = new THREE.Vector3();
            box.getCenter(center);
            const size = new THREE.Vector3();
            box.getSize(size);
            const maxDim = Math.max(size.x, size.y, size.z);
            if (maxDim === 0) return;
            for (const p of metricPointCloud) {
                vizPointCloud.push(p.clone().sub(center).divideScalar(maxDim));
            }
        }
        
        function updateVisualization() {
            if (scene) {
                if (pointCloud) scene.remove(pointCloud);
                if (meshSurface) scene.remove(meshSurface);
            }
            if (vizPointCloud.length === 0) {
                renderer.render(scene, camera);
                return;
            };
            if (document.getElementById('showPointCloud').checked) createPointCloudVisualization();
            if (document.getElementById('showMesh').checked) createMeshVisualization();
        }

        function createPointCloudVisualization() {
            const geometry = new THREE.BufferGeometry().setFromPoints(vizPointCloud);
            const material = new THREE.PointsMaterial({
                size: parseFloat(document.getElementById('pointSize').value),
                sizeAttenuation: false,
                color: 0x4facfe
            });
            pointCloud = new THREE.Points(geometry, material);
            scene.add(pointCloud);
        }
        
        function createMeshVisualization() {
            const geometry = new THREE.BufferGeometry().setFromPoints(vizPointCloud);
            const material = new THREE.MeshLambertMaterial({
                color: 0x00f2fe,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.8
            });
            meshSurface = new THREE.Mesh(geometry, material);
            // Note: Simple mesh from points is not ideal. This is for basic visualization.
            // A proper mesh generation (like Delaunay triangulation) is complex.
            scene.add(meshSurface);
        }

        function showLoading(show, text = 'Processing...') {
            document.getElementById('loading').style.display = show ? 'block' : 'none';
            document.getElementById('loadingText').textContent = text;
        }

        function updateProgress(percent) {
            document.getElementById('progressFill').style.width = percent + '%';
        }

        function showUI() {
            document.getElementById('statsSection').style.display = 'block';
            document.getElementById('vizSection').style.display = 'block';
            document.getElementById('volumeSection').style.display = 'block';
            document.getElementById('isolationSection').style.display = 'block';
            document.getElementById('advancedSection').style.display = 'block';
            document.getElementById('noiseReductionSection').style.display = 'block';
        }

        function updateStatsDisplay() {
            const grid = document.getElementById('statsGrid');
            grid.innerHTML = `
                <div class="stat-item"><div class="stat-value">${stats.pointCount.toLocaleString()}</div><div class="stat-label">Raw Points</div></div>
                <div class="stat-item"><div class="stat-value">${stats.imageWidth}√ó${stats.imageHeight}</div><div class="stat-label">Sensor Resolution</div></div>
                <div class="stat-item"><div class="stat-value">${stats.minDepth.toFixed(3)}m</div><div class="stat-label">Min Depth</div></div>
                <div class="stat-item"><div class="stat-value">${stats.maxDepth.toFixed(3)}m</div><div class="stat-label">Max Depth</div></div>
            `;
            document.getElementById('minDepthFilter').max = stats.maxDepth.toFixed(2);
            document.getElementById('maxDepthFilter').max = stats.maxDepth.toFixed(2);
        }

        function updateVolumeDisplay(volumeM3) {
            const volumeCm3 = volumeM3 * 1_000_000;
            const result = document.getElementById('volumeResult');
            result.innerHTML = `Volume: ${volumeCm3.toLocaleString(undefined, {maximumFractionDigits: 2})} cm¬≥`;
        }

        function setupBasicControls() {
            let isMouseDown = false;
            let prevMouseX = 0, prevMouseY = 0;
            const canvas = renderer.domElement;
            canvas.addEventListener('mousedown', e => { isMouseDown = true; prevMouseX = e.clientX; prevMouseY = e.clientY; });
            canvas.addEventListener('mouseup', () => isMouseDown = false);
            canvas.addEventListener('mouseout', () => isMouseDown = false);
            canvas.addEventListener('mousemove', e => {
                if (!isMouseDown) return;
                const deltaX = e.clientX - prevMouseX;
                const deltaY = e.clientY - prevMouseY;
                scene.rotation.y += deltaX * 0.005;
                scene.rotation.x += deltaY * 0.005;
                prevMouseX = e.clientX;
                prevMouseY = e.clientY;
            });
            canvas.addEventListener('wheel', e => { camera.position.z *= (e.deltaY > 0 ? 1.1 : 0.9); }, { passive: true });
        }

        function onWindowResize() {
            const container = document.querySelector('.main-view');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        // --- Event Listeners ---
        document.getElementById('csvFile').addEventListener('change', handleFileUpload);
        
        document.getElementById('removeNoiseBtn').addEventListener('click', handleRemoveNoise);

        const recalcControls = ['minDepthFilter', 'maxDepthFilter', 'voxelSize', 'cameraFov'];
        recalcControls.forEach(id => {
            document.getElementById(id).addEventListener('change', () => {
                 if(rawDepthData.length > 0) runFullPipeline();
            });
        });

        document.getElementById('minDepthFilter').addEventListener('input', e => {
            const min = parseFloat(e.target.value);
            const max = parseFloat(document.getElementById('maxDepthFilter').value);
            document.getElementById('depthFilterValue').textContent = `${min.toFixed(2)}-${max.toFixed(2)}`;
        });
        document.getElementById('maxDepthFilter').addEventListener('input', e => {
            const min = parseFloat(document.getElementById('minDepthFilter').value);
            const max = parseFloat(e.target.value);
            document.getElementById('depthFilterValue').textContent = `${min.toFixed(2)}-${max.toFixed(2)}`;
        });
        document.getElementById('pointSize').addEventListener('input', e => {
            document.getElementById('pointSizeValue').textContent = e.target.value;
            if (pointCloud) pointCloud.material.size = parseFloat(e.target.value);
        });
        document.getElementById('voxelSize').addEventListener('input', e => {
            document.getElementById('voxelSizeValue').textContent = e.target.value;
        });
        document.getElementById('cameraFov').addEventListener('input', e => {
            document.getElementById('fovValue').textContent = e.target.value;
        });
        
        document.getElementById('showPointCloud').addEventListener('change', updateVisualization);
        document.getElementById('showMesh').addEventListener('change', updateVisualization);

        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', (e) => {
                const newMethod = e.target.dataset.method;
                if(newMethod === 'voxel') {
                    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                    e.target.classList.add('active');
                    currentMethod = newMethod;
                    if (rawDepthData.length > 0) calculateVolume();
                } else {
                    alert("Only the Voxel method is implemented in this version.");
                }
            });
        });
        
        initThreeJS();
    </script>
</body>
</html>
